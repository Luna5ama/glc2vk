#version 460 core
// Generated by glsl-transformer
#extension GL_KHR_shader_subgroup_arithmetic: enable
#extension GL_KHR_shader_subgroup_basic: enable
#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_clustered: enable
#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_NV_shader_subgroup_partitioned: enable
#extension GL_KHR_shader_subgroup_ballot: enable
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
struct iris_FogParameters {
	vec4 color;
	float density;
	float start;
	float end;
	float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));
const float shadowDistance = 192.0f;
const float sunPathRotation = -20.0f;
const int shadowMapResolution = 2048;
const float ambientOcclusionLevel = 0.0f;
const float shadowDistanceRenderMul = 1.0f;
const float shadowIntervalSize = 0.0f;
const bool generateShadowMipmap = true;
const bool shadowHardwareFiltering = true;
const bool shadowtexMipmap = true;
const bool shadowtex0Mipmap = true;
const bool shadowtex1Mipmap = true;
uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int fogMode;
uniform float fogStart;
uniform float fogEnd;
uniform int fogShape;
uniform float fogDensity;
uniform vec3 fogColor;
uniform vec3 skyColor;
uniform int worldTime;
uniform int worldDay;
uniform int moonPhase;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float shadowAngle;
uniform float rainStrength;
uniform float near;
uniform float far;
uniform vec3 sunPosition;
uniform vec3 moonPosition;
uniform vec3 shadowLightPosition;
uniform vec3 upPosition;
uniform vec3 cameraPosition;
uniform vec3 previousCameraPosition;
uniform vec3 cameraPositionFract;
uniform ivec3 cameraPositionInt;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowProjectionInverse;
uniform mat4 shadowModelView;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform float eyeAltitude;
uniform ivec2 eyeBrightness;
uniform ivec2 eyeBrightnessSmooth;
uniform ivec2 terrainTextureSize;
uniform int terrainIconSize;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform float screenBrightness;
uniform int hideGUI;
uniform float centerDepthSmooth;
uniform ivec2 atlasSize;
uniform vec4 spriteBounds;
uniform vec4 entityColor;
uniform int entityId;
uniform int blockEntityId;
uniform ivec4 blendFunc;
uniform int instanceId;
uniform float playerMood;
uniform int renderStage;
uniform int bossBattle;
uniform mat4 modelViewMatrix;
uniform mat4 modelViewMatrixInverse;
uniform mat4 projectionMatrix;
uniform mat4 projectionMatrixInverse;
uniform mat4 textureMatrix = mat4(1.0f);
uniform mat3 normalMatrix;
uniform vec3 chunkOffset;
uniform float alphaTestRef;
uniform float darknessFactor;
uniform float darknessLightFactor;
float farPlane = far;
uniform vec2 uval_rtwsmMin;
uniform vec3 uval_sunDirView;
uniform vec3 uval_sunDirWorld;
uniform vec3 uval_moonDirView;
uniform vec3 uval_moonDirWorld;
uniform vec3 uval_shadowLightDirView;
uniform vec3 uval_shadowLightDirWorld;
uniform vec3 uval_upDirView;
uniform bool uval_sunVisible;
uniform vec2 uval_sunNdcPos;
uniform bool uval_moonVisible;
uniform vec2 uval_moonNdcPos;
uniform float uval_dayNightTransition;
uniform vec3 uval_cuDetailWind;
uniform vec2 uval_mainImageSize;
uniform vec2 uval_mainImageSizeRcp;
uniform int uval_mainImageSizeIX;
uniform int uval_mainImageSizeIY;
ivec2 uval_mainImageSizeI = ivec2(uval_mainImageSizeIX, uval_mainImageSizeIY);
uniform vec3 uval_cameraDelta;
struct AEData {
	vec3 expValues;
	uint shadowCount;
	uint highlightCount;
	uint weightSum;
	uint avgLumHistogram[256];
};
struct CameraData {
	uint frustumPlaneCount;
	vec4 frustumPlanes[6];
};
mat4 gbufferPrevModelView = gbufferPreviousModelView;
layout(std430, binding = 0) buffer GlobalData {
	uvec4 global_dispatchSize1;
	uvec4 global_dispatchSize2;
	uvec4 global_dispatchSize3;
	uvec4 global_dispatchSize4;
	mat4 gbufferPrevModelViewInverse;
	mat4 global_shadowRotationMatrix;
	mat4 global_shadowRotationMatrixInverse;
	mat4 global_taaJitterMat;
	mat4 global_camProj;
	mat4 global_camProjInverse;
	mat4 global_prevCamProj;
	mat4 global_prevCamProjInverse;
	mat4 global_shadowProjPrev;
	mat4 global_shadowProjInversePrev;
	mat4 global_shadowProj;
	mat4 global_shadowProjInverse;
	mat4 global_shadowView;
	mat4 global_shadowViewInverse;
	vec3 global_prevCameraDelta;
	vec2 global_taaJitter;
	CameraData global_cameraData;
	vec2 global_mipmapSizes[16];
	vec2 global_mipmapSizesRcp[16];
	ivec2 global_mipmapSizesI[16];
	ivec2 global_mipmapSizePrefixesPadded[16];
	ivec2 global_mipmapSizePrefixes[16];
	ivec4 global_mipmapTiles[2][16];
	uvec2 global_frameMortonJitter;
	ivec3 global_shadowAABBMinPrev;
	ivec3 global_shadowAABBMaxPrev;
	ivec3 global_shadowAABBMin;
	ivec3 global_shadowAABBMax;
	vec3 global_shadowAABBMinHistory;
	vec3 global_shadowAABBMaxHistory;
	ivec3 global_shadowAABBMinNew;
	ivec3 global_shadowAABBMaxNew;
	float global_focusDistance;
	int global_lastWorldTime;
	float global_historyResetFactor;
	float global_turbidity;
	AEData global_aeData;
	uint global_atomicCounters[16];
};
layout(std430, binding = 1) buffer IndirectComputeData { uint indirectComputeData[]; };
const vec2 SHADOW_MAP_SIZE = vec2(float(shadowMapResolution), 1.0f / float(shadowMapResolution));
const bool colortex0Clear = false;
const bool colortex1Clear = true;
const vec4 colortex1ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool colortex2Clear = true;
const vec4 colortex2ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool colortex3Clear = true;
const vec4 colortex3ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool colortex4Clear = true;
const vec4 colortex4ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool colortex5Clear = true;
const vec4 colortex5ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool colortex6Clear = true;
const vec4 colortex6ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool colortex7Clear = false;
const bool colortex8Clear = false;
const bool colortex9Clear = false;
const bool colortex10Clear = false;
const bool colortex11Clear = false;
const bool colortex12Clear = false;
const bool colortex13Clear = false;
const bool colortex14Clear = false;
const bool colortex15Clear = false;
const bool shadowcolor0Clear = true;
const vec4 shadowcolor0ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool shadowcolor1Clear = true;
const vec4 shadowcolor1ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool shadowcolor2Clear = true;
const vec4 shadowcolor2ClearColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);
const bool shadowcolor3Clear = true;
const vec4 shadowcolor3ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool shadowcolor4Clear = true;
const vec4 shadowcolor4ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool shadowcolor5Clear = true;
const vec4 shadowcolor5ClearColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);
const bool shadowcolor6Clear = true;
const vec4 shadowcolor6ClearColor = vec4(0.0f, 1.0f, 0.0f, 0.0f);
uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform usampler2D colortex7;
uniform usampler2D colortex8;
uniform usampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex11;
uniform sampler2D colortex12;
uniform usampler2D colortex13;
uniform usampler2D colortex14;
uniform sampler2D colortex15;
uniform sampler2D shadowtex0;
uniform sampler2DShadow shadowtex0HW;
uniform sampler2D shadowtex1;
uniform sampler2DShadow shadowtex1HW;
uniform sampler2D shadowcolor0;
uniform sampler2D shadowcolor1;
uniform sampler2D shadowcolor2;
uniform sampler2D shadowcolor3;
uniform sampler2D shadowcolor4;
uniform sampler2D shadowcolor5;
uniform sampler2D shadowcolor6;
uniform usampler2D usam_csrgba32ui;
uniform sampler2D usam_csrgba16f;
uniform sampler2D usam_cfrgba16f;
uniform sampler2D usam_csr32f;
uniform sampler2D usam_csrg32f;
uniform sampler2D usam_rtwsm_imap;
uniform sampler2D usam_transmittanceLUT;
uniform sampler2D usam_multiSctrLUT;
uniform sampler2D usam_skyLUT;
uniform sampler3D usam_skyViewLUT;
uniform usampler2D usam_epipolarData;
uniform sampler3D usam_cloudsAmbLUT;
uniform usampler2D usam_envProbe;
uniform sampler2D usam_causticsPhoton;
uniform sampler2D noisetex;
uniform sampler2D usam_waveNoise;
uniform sampler2D usam_waveHFCurl;
uniform sampler3D usam_blueNoise3D;
uniform sampler3D usam_whiteNoise3D;
uniform sampler3D usam_stbnVec1;
uniform sampler3D usam_stbnUnitVec2;
uniform sampler3D usam_stbnVec2;
uniform sampler2D usam_starmap;
uniform sampler2D usam_constellations;
uniform sampler2D usam_cirrus;
uniform sampler2D usam_cloudPhases;
uniform sampler2D usam_hiz;
uniform sampler3D usam_cumulusDetail1;
uniform sampler3D usam_cumulusCurl;
float mmin3(float x, float y, float z) {
	return min(min(x, y), z);
}
float mmax3(float x, float y, float z) {
	return max(max(x, y), z);
}
float max2(float x, float y) {
	return max(x, y);
}
float max2(vec2 v) {
	return max(v.x, v.y);
}
float mmax3(vec3 v) {
	return max(max(v.x, v.y), v.z);
}
float max4(float x, float y, float z, float w) {
	return max(max(x, y), max(z, w));
}
float max4(vec4 v) {
	return max(max(v.x, v.y), max(v.z, v.w));
}
float min2(float x, float y) {
	return min(x, y);
}
float min2(vec2 v) {
	return min(v.x, v.y);
}
float mmin3(vec3 v) {
	return min(min(v.x, v.y), v.z);
}
float min4(float x, float y, float z, float w) {
	return min(min(x, y), min(z, w));
}
float min4(vec4 v) {
	return min(min(v.x, v.y), min(v.z, v.w));
}
float sum2(float x, float y) {
	return x + y;
}
float sum2(vec2 v) {
	return v.x + v.y;
}
float sum3(float x, float y, float z) {
	return x + y + z;
}
float sum3(vec3 v) {
	return v.x + v.y + v.z;
}
float sum4(float x, float y, float z, float w) {
	return x + y + z + w;
}
float sum4(vec4 v) {
	return v.x + v.y + v.z + v.w;
}
float linearStep(float edge0, float edge1, float x) {
	return clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);
}
vec2 linearStep(float edge0, float edge1, vec2 x) {
	return clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);
}
vec3 linearStep(float edge0, float edge1, vec3 x) {
	return clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);
}
vec4 linearStep(float edge0, float edge1, vec4 x) {
	return clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);
}
float pow2(float x) {
	return x * x;
}
vec2 pow2(vec2 x) {
	return x * x;
}
vec3 pow2(vec3 x) {
	return x * x;
}
vec4 pow2(vec4 x) {
	return x * x;
}
float pow3(float x) {
	return x * x * x;
}
vec2 pow3(vec2 x) {
	return x * x * x;
}
vec3 pow3(vec3 x) {
	return x * x * x;
}
vec4 pow3(vec4 x) {
	return x * x * x;
}
float pow4(float x) {
	float x2 = x * x;
	return x2 * x2;
}
vec2 pow4(vec2 x) {
	vec2 x2 = x * x;
	return x2 * x2;
}
vec3 pow4(vec3 x) {
	vec3 x2 = x * x;
	return x2 * x2;
}
vec4 pow4(vec4 x) {
	vec4 x2 = x * x;
	return x2 * x2;
}
float pow5(float x) {
	float x2 = x * x;
	return x2 * x2 * x;
}
vec2 pow5(vec2 x) {
	vec2 x2 = x * x;
	return x2 * x2 * x;
}
vec3 pow5(vec3 x) {
	vec3 x2 = x * x;
	return x2 * x2 * x;
}
vec4 pow5(vec4 x) {
	vec4 x2 = x * x;
	return x2 * x2 * x;
}
float pow6(float x) {
	float x2 = x * x;
	return x2 * x2 * x2;
}
vec2 pow6(vec2 x) {
	vec2 x2 = x * x;
	return x2 * x2 * x2;
}
vec3 pow6(vec3 x) {
	vec3 x2 = x * x;
	return x2 * x2 * x2;
}
vec4 pow6(vec4 x) {
	vec4 x2 = x * x;
	return x2 * x2 * x2;
}
float lengthSq(float x) {
	return x * x;
}
float lengthSq(vec2 x) {
	return dot(x, x);
}
float lengthSq(vec3 x) {
	return dot(x, x);
}
float lengthSq(vec4 x) {
	return dot(x, x);
}
float raySphereIntersectNearest(vec3 r0, vec3 rd, vec3 s0, float sR) {
	float a = dot(rd, rd);
	vec3 s0_r0 = r0 - s0;
	float b = 2.0f * dot(rd, s0_r0);
	float c = dot(s0_r0, s0_r0) - (sR * sR);
	float delta = b * b - 4.0f * a * c;
	if (delta < 0.0f || a == 0.0f) {
		return -1.0f;
	}
	float sol0 = (-b - sqrt(delta)) / (2.0f * a);
	float sol1 = (-b + sqrt(delta)) / (2.0f * a);
	if (sol0 < 0.0f && sol1 < 0.0f) {
		return -1.0f;
	}
	if (sol0 < 0.0f) {
		return max(0.0f, sol1);
	} else if (sol1 < 0.0f) {
		return max(0.0f, sol0);
	}
	return max(0.0f, min(sol0, sol1));
}
float softMin(float x, float maxV) {
	float phiX = x - maxV / 2.0f;
	float phi = maxV / (1.0f + exp((-4.0f * phiX) / maxV));
	return min(x, phi);
}
const mat3 _colors2_colorspaces_mat_CIE_XYZ_to_CIE_XYZ = mat3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
const mat3 _colors2_colorspaces_mat_CIE_XYZ_to_SRGB = mat3(3.2406f, -1.5372f, -0.4986f, -0.9689f, 1.8758f, 0.0415f, 0.0557f, -0.204f, 1.057f);
const mat3 _colors2_colorspaces_mat_CIE_XYZ_to_REC709 = mat3(3.2409699419f, -1.5373831776f, -0.4986107603f, -0.9692436363f, 1.8759675015f, 0.0415550574f, 0.0556300797f, -0.2039769589f, 1.0569715142f);
const mat3 _colors2_colorspaces_mat_CIE_XYZ_to_REC2020 = mat3(1.716651188f, -0.3556707838f, -0.2533662814f, -0.6666843518f, 1.6164812366f, 0.0157685458f, 0.0176398574f, -0.0427706133f, 0.9421031212f);
const mat3 _colors2_colorspaces_mat_CIE_XYZ_to_DCI_P3 = mat3(2.7253940305f, -1.0180030062f, -0.4401631952f, -0.7951680258f, 1.6897320548f, 0.0226471906f, 0.0412418914f, -0.0876390192f, 1.1009293786f);
const mat3 _colors2_colorspaces_mat_CIE_XYZ_to_ADOBE_RGB_1998 = mat3(2.04159f, -0.56501f, -0.34473f, -0.96924f, 1.87597f, 0.04156f, 0.01344f, -0.11836f, 1.01517f);
const mat3 _colors2_colorspaces_mat_CIE_XYZ_to_ACES_AP0 = mat3(1.0498110175f, 0.0f, -9.74845E-5f, -0.4959030231f, 1.3733130458f, 0.0982400361f, 0.0f, 0.0f, 0.9912520182f);
const mat3 _colors2_colorspaces_mat_CIE_XYZ_to_ACES_AP1 = mat3(1.6410233797f, -0.3248032942f, -0.2364246952f, -0.6636628587f, 1.6153315917f, 0.0167563477f, 0.0117218943f, -0.008284442f, 0.9883948585f);
const mat3 _colors2_colorspaces_mat_SRGB_to_CIE_XYZ = mat3(0.4124f, 0.3576f, 0.1805f, 0.2126f, 0.7152f, 0.0722f, 0.0193f, 0.1192f, 0.9505f);
const mat3 _colors2_colorspaces_mat_SRGB_to_SRGB = mat3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
const mat3 _colors2_colorspaces_mat_SRGB_to_REC709 = mat3(1.0001051528f, 0.0f, 6.64814E-5f, -8.33722E-5f, 1.0000437956f, -5.5407E-6f, -2.41064E-5f, 0.0f, 0.9999655172f);
const mat3 _colors2_colorspaces_mat_SRGB_to_REC2020 = mat3(0.6274413721f, 0.3292974595f, 0.0433514584f, 0.0690276171f, 0.9195806669f, 0.0113614226f, 0.0163642351f, 0.0880171625f, 0.8955649727f);
const mat3 _colors2_colorspaces_mat_SRGB_to_DCI_P3 = mat3(0.8686602648f, 0.1289247846f, 0.0025580657f, 0.034463766f, 0.9618535095f, 0.0036450448f, 0.0167452803f, 0.071043109f, 0.9121578398f);
const mat3 _colors2_colorspaces_mat_SRGB_to_ADOBE_RGB_1998 = mat3(0.715177301f, 0.284885616f, 4.7408E-5f, -8.1246E-5f, 1.000047472f, -6.0E-9f, -2.7899E-5f, 0.041163336f, 0.958799413f);
const mat3 _colors2_colorspaces_mat_SRGB_to_ACES_AP0 = mat3(0.439643004f, 0.3830054714f, 0.1773993089f, 0.0897157319f, 0.8134750538f, 0.0967822524f, 0.0175127205f, 0.1115514385f, 0.870882793f);
const mat3 _colors2_colorspaces_mat_SRGB_to_ACES_AP1 = mat3(0.6131324224f, 0.3395380158f, 0.047416696f, 0.0701243808f, 0.9163940113f, 0.013451524f, 0.0205876575f, 0.1095745716f, 0.869785404f);
const mat3 _colors2_colorspaces_mat_REC709_to_CIE_XYZ = mat3(0.4123907993f, 0.3575843394f, 0.1804807884f, 0.2126390059f, 0.7151686788f, 0.0721923154f, 0.0193308187f, 0.1191947798f, 0.9505321522f);
const mat3 _colors2_colorspaces_mat_REC709_to_SRGB = mat3(0.9998865981f, 0.0f, -4.33154E-5f, 1.050308E-4f, 0.9999965246f, -2.4064E-6f, 2.44857E-5f, 1.19195E-5f, 1.0000380325f);
const mat3 _colors2_colorspaces_mat_REC709_to_REC709 = mat3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
const mat3 _colors2_colorspaces_mat_REC709_to_REC2020 = mat3(0.6274038959f, 0.3292830384f, 0.0433130657f, 0.0690972894f, 0.9195403951f, 0.0113623156f, 0.0163914389f, 0.0880133079f, 0.8955952532f);
const mat3 _colors2_colorspaces_mat_REC709_to_DCI_P3 = mat3(0.8685797397f, 0.1289191385f, 0.0025011218f, 0.0345404103f, 0.9618113864f, 0.0036482034f, 0.016771429f, 0.0710399978f, 0.9121885732f);
const mat3 _colors2_colorspaces_mat_REC709_to_ADOBE_RGB_1998 = mat3(0.715125854f, 0.2848731398f, 1.4438E-6f, 2.1264E-6f, 1.0000036763f, 5.5347E-6f, -1.3532E-6f, 0.0411615333f, 0.9588327043f);
const mat3 _colors2_colorspaces_mat_REC709_to_ACES_AP0 = mat3(0.4396329819f, 0.3829886982f, 0.17737832f, 0.0897764429f, 0.8134394287f, 0.0967841283f, 0.0175411704f, 0.1115465533f, 0.8709122763f);
const mat3 _colors2_colorspaces_mat_REC709_to_ACES_AP1 = mat3(0.6130974024f, 0.3395231462f, 0.0473794514f, 0.0701937225f, 0.9163538791f, 0.0134523985f, 0.0206155929f, 0.1095697729f, 0.8698146342f);
const mat3 _colors2_colorspaces_mat_REC2020_to_CIE_XYZ = mat3(0.6369580483f, 0.1446169036f, 0.1688809752f, 0.262700212f, 0.6779980715f, 0.0593017165f, 0.0f, 0.028072693f, 1.0609850577f);
const mat3 _colors2_colorspaces_mat_REC2020_to_SRGB = mat3(1.6603034854f, -0.5875701425f, -0.0728900602f, -0.1243755953f, 1.1328344814f, -0.0083597372f, -0.01811228f, -0.1005836085f, 1.1187703262f);
const mat3 _colors2_colorspaces_mat_REC2020_to_REC709 = mat3(1.6604910021f, -0.5876411388f, -0.0728498633f, -0.1245504745f, 1.1328998971f, -0.0083494226f, -0.0181507634f, -0.100578898f, 1.1187296614f);
const mat3 _colors2_colorspaces_mat_REC2020_to_REC2020 = mat3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
const mat3 _colors2_colorspaces_mat_REC2020_to_DCI_P3 = mat3(1.4261665053f, -0.3646122688f, -0.0615542365f, -0.0625062418f, 1.0689717224f, -0.0064654806f, 0.0024438227f, -0.0211212969f, 1.0186774743f);
const mat3 _colors2_colorspaces_mat_REC2020_to_ADOBE_RGB_1998 = mat3(1.151978935f, -0.0975047657f, -0.0544737317f, -0.124547502f, 1.1329022557f, -0.0083434163f, -0.0225324809f, -0.0498056448f, 1.0723310102f);
const mat3 _colors2_colorspaces_mat_REC2020_to_ACES_AP0 = mat3(0.6790856347f, 0.1577009146f, 0.1632134507f, 0.0460020031f, 0.859054673f, 0.094943324f, -5.739432E-4f, 0.0284677684f, 0.9721061748f);
const mat3 _colors2_colorspaces_mat_REC2020_to_ACES_AP1 = mat3(0.9748949779f, 0.0195991086f, 0.0055059134f, 0.0021795628f, 0.9955354689f, 0.0022849683f, 0.0047972397f, 0.0245320166f, 0.9706707437f);
const mat3 _colors2_colorspaces_mat_DCI_P3_to_CIE_XYZ = mat3(0.4451698156f, 0.2771344092f, 0.1722826698f, 0.2094916779f, 0.7215952542f, 0.0689130679f, -0.0f, 0.0470605601f, 0.9073553944f);
const mat3 _colors2_colorspaces_mat_DCI_P3_to_SRGB = mat3(1.1573859234f, -0.1549414014f, -0.0026012394f, -0.041378309f, 1.0455482025f, -0.0040707446f, -0.0180228775f, -0.0785725929f, 1.0966699081f);
const mat3 _colors2_colorspaces_mat_DCI_P3_to_REC709 = mat3(1.1575164062f, -0.1549623781f, -0.0025540281f, -0.0415000715f, 1.0455679231f, -0.0040678515f, -0.018050039f, -0.0785782727f, 1.0966283116f);
const mat3 _colors2_colorspaces_mat_DCI_P3_to_REC2020 = mat3(0.7117832307f, 0.2436603169f, 0.0445564524f, 0.0416151636f, 0.9498416297f, 0.0085432067f, -8.447284E-4f, 0.0191095072f, 0.9817352212f);
const mat3 _colors2_colorspaces_mat_DCI_P3_to_DCI_P3 = mat3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
const mat3 _colors2_colorspaces_mat_DCI_P3_to_ADOBE_RGB_1998 = mat3(0.8159476268f, 0.1870365007f, -0.0029836898f, -0.0414978627f, 1.0455710024f, -0.0040618024f, -0.0190167405f, -0.0323060291f, 1.0513156541f);
const mat3 _colors2_colorspaces_mat_DCI_P3_to_ACES_AP0 = mat3(0.4897866453f, 0.3183760433f, 0.1918373114f, 0.0684129538f, 0.8289890733f, 0.1025979728f, -4.4998E-5f, 0.0454764943f, 0.9545685037f);
const mat3 _colors2_colorspaces_mat_DCI_P3_to_ACES_AP1 = mat3(0.6947248661f, 0.2562644839f, 0.04901065f, 0.0429788175f, 0.9461757697f, 0.0108454127f, 0.0036155455f, 0.0430194671f, 0.9533649873f);
const mat3 _colors2_colorspaces_mat_ADOBE_RGB_1998_to_CIE_XYZ = mat3(0.57667f, 0.18556f, 0.18823f, 0.29734f, 0.62736f, 0.07529f, 0.02703f, 0.07069f, 0.99134f);
const mat3 _colors2_colorspaces_mat_ADOBE_RGB_1998_to_SRGB = mat3(1.398208596f, -0.39829809f, -3.9774E-5f, 1.36554E-4f, 0.999946439f, -6.455E-6f, 3.3869E-5f, -0.042926418f, 1.042971631f);
const mat3 _colors2_colorspaces_mat_ADOBE_RGB_1998_to_REC709 = mat3(1.3983671735f, -0.3983451225f, 5.4016E-6f, -1.03176E-5f, 0.9999916496f, -3.9459E-6f, -3.709E-7f, -0.042926951f, 1.0429319656f);
const mat3 _colors2_colorspaces_mat_ADOBE_RGB_1998_to_REC2020 = mat3(0.8773375991f, 0.0774977091f, 0.0451746704f, 0.0966138895f, 0.8915203988f, 0.011846867f, 0.0229200098f, 0.0430379497f, 0.9340446591f);
const mat3 _colors2_colorspaces_mat_ADOBE_RGB_1998_to_DCI_P3 = mat3(1.2145920645f, -0.2171838064f, 0.0026126829f, 0.0482902509f, 0.9478877447f, 0.0038012193f, 0.0234515446f, 0.0252011134f, 0.9513504319f);
const mat3 _colors2_colorspaces_mat_ADOBE_RGB_1998_to_ADOBE_RGB_1998 = mat3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
const mat3 _colors2_colorspaces_mat_ADOBE_RGB_1998_to_ACES_AP0 = mat3(0.614764313f, 0.2002455356f, 0.1849943834f, 0.1255320021f, 0.7735159805f, 0.1009365364f, 0.024527523f, 0.0671725736f, 0.9083019068f);
const mat3 _colors2_colorspaces_mat_ADOBE_RGB_1998_to_ACES_AP1 = mat3(0.857331761f, 0.0932620958f, 0.0494155164f, 0.0981471377f, 0.8878074297f, 0.0140266997f, 0.0288267153f, 0.0640182469f, 0.9071571651f);
const mat3 _colors2_colorspaces_mat_ACES_AP0_to_CIE_XYZ = mat3(0.9525523959f, 0.0f, 9.36786E-5f, 0.3439664498f, 0.7281660966f, -0.0721325464f, 0.0f, 0.0f, 1.0088251844f);
const mat3 _colors2_colorspaces_mat_ACES_AP0_to_SRGB = mat3(2.5214008886f, -1.1339957494f, -0.3875618568f, -0.2762140616f, 1.3725955663f, -0.0962823557f, -0.0153202001f, -0.1529925618f, 1.1683871996f);
const mat3 _colors2_colorspaces_mat_ACES_AP0_to_REC709 = mat3(2.5216861866f, -1.1341309882f, -0.3875551986f, -0.2764799141f, 1.3727190876f, -0.0962391734f, -0.015378065f, -0.1529753359f, 1.1683534009f);
const mat3 _colors2_colorspaces_mat_ACES_AP0_to_REC2020 = mat3(1.4904095205f, -0.2661709193f, -0.2242386013f, -0.0801674998f, 1.1821671211f, -0.1019996212f, 0.0032276312f, -0.0347764757f, 1.0315488446f);
const mat3 _colors2_colorspaces_mat_ACES_AP0_to_DCI_P3 = mat3(2.1546035168f, -0.8084960464f, -0.3461074707f, -0.1788775564f, 1.280565414f, -0.1016878576f, 0.0086234533f, -0.0610453898f, 1.0524219365f);
const mat3 _colors2_colorspaces_mat_ACES_AP0_to_ADOBE_RGB_1998 = mat3(1.7245612643f, -0.4199958158f, -0.304565011f, -0.2764756536f, 1.3727208758f, -0.0962338848f, -0.0261287411f, -0.0901729979f, 1.1162946235f);
const mat3 _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP0 = mat3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
const mat3 _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP1 = mat3(1.4514393161f, -0.2365107469f, -0.2149285693f, -0.0765537733f, 1.1762296998f, -0.0996759265f, 0.0083161484f, -0.0060324498f, 0.9977163014f);
const mat3 _colors2_colorspaces_mat_ACES_AP1_to_CIE_XYZ = mat3(0.6624541811f, 0.1340042065f, 0.156187687f, 0.2722287168f, 0.6740817658f, 0.0536895174f, -0.0055746495f, 0.0040607335f, 1.0103391003f);
const mat3 _colors2_colorspaces_mat_ACES_AP1_to_SRGB = mat3(1.7048586763f, -0.6217160219f, -0.0832993717f, -0.1300768242f, 1.1407357748f, -0.0105598017f, -0.0239640729f, -0.1289755083f, 1.1530140189f);
const mat3 _colors2_colorspaces_mat_ACES_AP1_to_REC709 = mat3(1.7050509927f, -0.6217921207f, -0.083258872f, -0.1302564175f, 1.1408047366f, -0.0105483191f, -0.0240033568f, -0.1289689761f, 1.1529723329f);
const mat3 _colors2_colorspaces_mat_ACES_AP1_to_REC2020 = mat3(1.0258247477f, -0.0200531908f, -0.0057715568f, -0.0022343695f, 1.0045865019f, -0.0023521324f, -0.0050133515f, -0.0252900718f, 1.0303034233f);
const mat3 _colors2_colorspaces_mat_ACES_AP1_to_DCI_P3 = mat3(1.464120167f, -0.3933270416f, -0.0707931253f, -0.0664765138f, 1.0752915253f, -0.0088150114f, -0.0025528617f, -0.0470296027f, 1.0495824644f);
const mat3 _colors2_colorspaces_mat_ACES_AP1_to_ADOBE_RGB_1998 = mat3(1.182219458f, -0.1196751803f, -0.06254384f, -0.1302534036f, 1.1408068945f, -0.0105421535f, -0.0283790646f, -0.0767015586f, 1.1050735076f);
const mat3 _colors2_colorspaces_mat_ACES_AP1_to_ACES_AP0 = mat3(0.6954522414f, 0.1406786965f, 0.1638690622f, 0.0447945634f, 0.8596711184f, 0.0955343182f, -0.0055258826f, 0.0040252103f, 1.0015006723f);
const mat3 _colors2_colorspaces_mat_ACES_AP1_to_ACES_AP1 = mat3(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
float colors2_oetf_identity(float c) {
	return c;
}
vec3 colors2_oetf_identity(vec3 c) {
	return c;
}
float colors2_eotf_identity(float c) {
	return c;
}
vec3 colors2_eotf_identity(vec3 c) {
	return c;
}
float colors2_oetf_Rec601(float c) {
	float lower = 4.5f * c;
	float higher = pow(c, 0.45f) * 1.099f - 0.099f;
	return mix(lower, higher, c >= 0.018f);
}
vec3 colors2_oetf_Rec601(vec3 c) {
	vec3 lower = 4.5f * c;
	vec3 higher = pow(c, vec3(0.45f)) * 1.099f - 0.099f;
	return mix(lower, higher, greaterThanEqual(c, vec3(0.018f)));
}
float colors2_eotf_Rec601(float c) {
	float lower = c / 4.5f;
	float higher = pow((c + 0.099f) / 1.099f, 1.0f / 0.45f);
	return mix(lower, higher, c >= 0.081f);
}
vec3 colors2_eotf_Rec601(vec3 c) {
	vec3 lower = c / 4.5f;
	vec3 higher = pow((c + 0.099f) / 1.099f, vec3(1.0f / 0.45f));
	return mix(lower, higher, greaterThanEqual(c, vec3(0.081f)));
}
float colors2_oetf_Rec709(float c) {
	return colors2_oetf_Rec601(c);
}
vec3 colors2_oetf_Rec709(vec3 c) {
	return colors2_oetf_Rec601(c);
}
float colors2_eotf_Rec709(float c) {
	return colors2_eotf_Rec601(c);
}
vec3 colors2_eotf_Rec709(vec3 c) {
	return colors2_eotf_Rec601(c);
}
float colors2_oetf_sRGB(float c) {
	float lower = 12.92f * c;
	float higher = pow(c, 1.0f / 2.4f) * 1.055f - 0.055f;
	return mix(lower, higher, c > 0.0031308f);
}
vec3 colors2_oetf_sRGB(vec3 c) {
	vec3 lower = 12.92f * c;
	vec3 higher = pow(c, vec3(1.0f / 2.4f)) * 1.055f - 0.055f;
	return mix(lower, higher, greaterThan(c, vec3(0.0031308f)));
}
float colors2_eotf_sRGB(float c) {
	float lower = c / 12.92f;
	float higher = pow((c + 0.055f) / 1.055f, 2.4f);
	return mix(lower, higher, c > 0.04045f);
}
vec3 colors2_eotf_sRGB(vec3 c) {
	vec3 lower = c / 12.92f;
	vec3 higher = pow((c + 0.055f) / 1.055f, vec3(2.4f));
	return mix(lower, higher, greaterThan(c, vec3(0.04045f)));
}
float colors2_oetf_Exp22(float c) {
	return pow(c, 1.0f / 2.2f);
}
vec3 colors2_oetf_Exp22(vec3 c) {
	return pow(c, vec3(1.0f / 2.2f));
}
float colors2_eotf_Exp22(float c) {
	return pow(c, 2.2f);
}
vec3 colors2_eotf_Exp22(vec3 c) {
	return pow(c, vec3(2.2f));
}
float colors2_oetf_Exp24(float c) {
	return pow(c, 1.0f / 2.4f);
}
vec3 colors2_oetf_Exp24(vec3 c) {
	return pow(c, vec3(1.0f / 2.4f));
}
float colors2_eotf_Exp24(float c) {
	return pow(c, 2.4f);
}
vec3 colors2_eotf_Exp24(vec3 c) {
	return pow(c, vec3(2.4f));
}
const float _PQ_M1 = 2610.0f / 16384.0f;
const float _PQ_M2 = 2523.0f / 4096.0f * 128.0f;
const float _PQ_C1 = 3424.0f / 4096.0f;
const float _PQ_C2 = 2413.0f / 4096.0f * 32.0f;
const float _PQ_C3 = 2392.0f / 4096.0f * 32.0f;
const float _PQ_PEAK = 10000.0f;
float colors2_oetf_PQ(float c) {
	float y = c / _PQ_PEAK;
	float yPow = pow(y, _PQ_M1);
	float numerator = _PQ_C1 + _PQ_C2 * yPow;
	float denominator = 1.0f + _PQ_C3 * yPow;
	return pow(numerator / denominator, _PQ_M2);
}
vec3 colors2_oetf_PQ(vec3 c) {
	vec3 y = c / _PQ_PEAK;
	vec3 yPow = pow(y, vec3(_PQ_M1));
	vec3 numerator = vec3(_PQ_C1) + vec3(_PQ_C2) * yPow;
	vec3 denominator = vec3(1.0f) + vec3(_PQ_C3) * yPow;
	return pow(numerator / denominator, vec3(_PQ_M2));
}
float colors2_eotf_PQ(float c) {
	float ePow = pow(c, 1.0f / _PQ_M2);
	float numerator = max(ePow - _PQ_C1, 0.0f);
	float denominator = _PQ_C2 - _PQ_C3 * ePow;
	float y = pow(numerator / denominator, 1.0f / _PQ_M1);
	return y * _PQ_PEAK;
}
vec3 colors2_eotf_PQ(vec3 c) {
	vec3 ePow = pow(c, vec3(1.0f / _PQ_M2));
	vec3 numerator = max(ePow - vec3(_PQ_C1), 0.0f);
	vec3 denominator = _PQ_C2 - _PQ_C3 * ePow;
	vec3 y = pow(numerator / denominator, vec3(1.0f / _PQ_M1));
	return y * _PQ_PEAK;
}
const float _HLG_A = 0.17883277f;
const float _HLG_B = 1.0f - 4.0f * _HLG_A;
const float _HLG_C = 0.5f - _HLG_A * log(4.0f * _HLG_A);
float colors2_oetf_HLG(float c) {
	float lower = sqrt(3.0f * c);
	float higher = _HLG_A * log(12.0f * c - _HLG_B) + _HLG_C;
	return mix(lower, higher, c > 1.0f / 12.0f);
}
vec3 colors2_oetf_HLG(vec3 c) {
	vec3 lower = sqrt(3.0f * c);
	vec3 higher = _HLG_A * log(12.0f * c - _HLG_B) + _HLG_C;
	return mix(lower, higher, greaterThan(c, vec3(1.0f / 12.0f)));
}
float colors2_eotf_HLG(float c) {
	float lower = c * c / 3.0f;
	float higher = (exp((c - _HLG_C) / _HLG_A) + _HLG_B) / 12.0f;
	return mix(lower, higher, c > 0.5f);
}
vec3 colors2_eotf_HLG(vec3 c) {
	vec3 lower = c * c / 3.0f;
	vec3 higher = (exp((c - vec3(_HLG_C)) / vec3(_HLG_A)) + vec3(_HLG_B)) / 12.0f;
	return mix(lower, higher, greaterThan(c, vec3(0.5f)));
}
float colors2_oetf_0(float c) {
	return colors2_eotf_identity(c);
}
vec3 colors2_oetf_0(vec3 c) {
	return colors2_eotf_identity(c);
}
float colors2_eotf_0(float c) {
	return colors2_oetf_identity(c);
}
vec3 colors2_eotf_0(vec3 c) {
	return colors2_oetf_identity(c);
}
float colors2_oetf_1(float c) {
	return colors2_oetf_Rec601(c);
}
vec3 colors2_oetf_1(vec3 c) {
	return colors2_oetf_Rec601(c);
}
float colors2_eotf_1(float c) {
	return colors2_eotf_Rec601(c);
}
vec3 colors2_eotf_1(vec3 c) {
	return colors2_eotf_Rec601(c);
}
float colors2_oetf_2(float c) {
	return colors2_oetf_Rec709(c);
}
vec3 colors2_oetf_2(vec3 c) {
	return colors2_oetf_Rec709(c);
}
float colors2_eotf_2(float c) {
	return colors2_eotf_Rec709(c);
}
vec3 colors2_eotf_2(vec3 c) {
	return colors2_eotf_Rec709(c);
}
float colors2_oetf_3(float c) {
	return colors2_oetf_sRGB(c);
}
vec3 colors2_oetf_3(vec3 c) {
	return colors2_oetf_sRGB(c);
}
float colors2_eotf_3(float c) {
	return colors2_eotf_sRGB(c);
}
vec3 colors2_eotf_3(vec3 c) {
	return colors2_eotf_sRGB(c);
}
float colors2_oetf_4(float c) {
	return colors2_oetf_Exp22(c);
}
vec3 colors2_oetf_4(vec3 c) {
	return colors2_oetf_Exp22(c);
}
float colors2_eotf_4(float c) {
	return colors2_eotf_Exp22(c);
}
vec3 colors2_eotf_4(vec3 c) {
	return colors2_eotf_Exp22(c);
}
float colors2_oetf_5(float c) {
	return colors2_oetf_Exp24(c);
}
vec3 colors2_oetf_5(vec3 c) {
	return colors2_oetf_Exp24(c);
}
float colors2_eotf_5(float c) {
	return colors2_eotf_Exp24(c);
}
vec3 colors2_eotf_5(vec3 c) {
	return colors2_eotf_Exp24(c);
}
float colors2_oetf_6(float c) {
	return colors2_oetf_PQ(c);
}
vec3 colors2_oetf_6(vec3 c) {
	return colors2_oetf_PQ(c);
}
float colors2_eotf_6(float c) {
	return colors2_eotf_PQ(c);
}
vec3 colors2_eotf_6(vec3 c) {
	return colors2_eotf_PQ(c);
}
float colors2_oetf_7(float c) {
	return colors2_oetf_HLG(c);
}
vec3 colors2_oetf_7(vec3 c) {
	return colors2_oetf_HLG(c);
}
float colors2_eotf_7(float c) {
	return colors2_eotf_HLG(c);
}
vec3 colors2_eotf_7(vec3 c) {
	return colors2_eotf_HLG(c);
}
vec3 colors_Rec601_encodeGamma(vec3 color) {
	vec3 lower = 4.5f * color;
	vec3 higher = pow(color, vec3(0.45f)) * 1.099f - 0.099f;
	return mix(lower, higher, greaterThanEqual(color, vec3(0.018f)));
}
vec3 colors_Rec601_decodeGamma(vec3 color) {
	vec3 lower = color / 4.5f;
	vec3 higher = pow((color + 0.099f) / 1.099f, vec3(1.0f / 0.45f));
	return mix(lower, higher, greaterThanEqual(color, vec3(0.081f)));
}
float colors_Rec601_luma(vec3 color) {
	return dot(color, vec3(0.299f, 0.587f, 0.114f));
}
vec3 colors_Rec709_encodeGamma(vec3 color) {
	return colors_Rec601_encodeGamma(color);
}
vec3 colors_Rec709_decodeGamma(vec3 color) {
	return colors_Rec601_decodeGamma(color);
}
float colors_Rec709_luma(vec3 color) {
	return dot(color, vec3(0.2126f, 0.7152f, 0.0722f));
}
float colors_sRGB_encodeGamma(float color) {
	float lower = 12.92f * color;
	float higher = pow(color, 1.0f / 2.4f) * 1.055f - 0.055f;
	return mix(lower, higher, color > 0.0031308f);
}
vec2 colors_sRGB_encodeGamma(vec2 color) {
	vec2 lower = 12.92f * color;
	vec2 higher = pow(color, vec2(1.0f / 2.4f)) * 1.055f - 0.055f;
	return mix(lower, higher, greaterThan(color, vec2(0.0031308f)));
}
vec3 colors_sRGB_encodeGamma(vec3 color) {
	vec3 lower = 12.92f * color;
	vec3 higher = pow(color, vec3(1.0f / 2.4f)) * 1.055f - 0.055f;
	return mix(lower, higher, greaterThan(color, vec3(0.0031308f)));
}
vec4 colors_sRGB_encodeGamma(vec4 color) {
	vec4 lower = 12.92f * color;
	vec4 higher = pow(color, vec4(1.0f / 2.4f)) * 1.055f - 0.055f;
	return mix(lower, higher, greaterThan(color, vec4(0.0031308f)));
}
float colors_sRGB_decodeGamma(float color) {
	float lower = color / 12.92f;
	float higher = pow((color + 0.055f) / 1.055f, 2.4f);
	return mix(lower, higher, color > 0.04045f);
}
vec3 colors_sRGB_decodeGamma(vec3 color) {
	vec3 lower = color / 12.92f;
	vec3 higher = pow((color + 0.055f) / 1.055f, vec3(2.4f));
	return mix(lower, higher, greaterThan(color, vec3(0.04045f)));
}
float colors_sRGB_luma(vec3 color) {
	return colors_Rec709_luma(color);
}
const mat3 _SRGB_TO_YCOCG = mat3(0.25f, 0.5f, -0.25f, 0.5f, 0.0f, 0.5f, 0.25f, -0.5f, -0.25f);
vec3 colors_SRGBToYCoCg(vec3 color) {
	return _SRGB_TO_YCOCG * color;
}
const mat3 _YCOCG_TO_SRGB = mat3(1.0f, 1.0f, 1.0f, 1.0f, 0.0f, -1.0f, -1.0f, 1.0f, -1.0f);
vec3 colors_YCoCgToSRGB(vec3 color) {
	return _YCOCG_TO_SRGB * color;
}
const mat3 _COLORS_LOGLUV32_M = mat3(0.2209f, 0.339f, 0.4184f, 0.1138f, 0.678f, 0.7319f, 0.0102f, 0.113f, 0.2969f);
vec4 colors_sRGBToLogLuv32(in vec3 vRGB) {
	if (all(lessThanEqual(vRGB, vec3(0.0f)))) {
		return vec4(0.0f);
	}
	vec4 vResult;
	vec3 Xp_Y_XYZp = _COLORS_LOGLUV32_M * vRGB;
	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1.0E-6f, 1.0E-6f, 1.0E-6f));
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2 * log2(Xp_Y_XYZp.y) + 127;
	vResult.w = fract(Le);
	vResult.z = (Le - (floor(vResult.w * 255.0f)) / 255.0f) / 255.0f;
	return vResult;
}
const mat3 _COLORS_LOGLUV32_INVERSE_M = mat3(6.0014f, -2.7008f, -1.7996f, -1.332f, 3.1029f, -5.7721f, 0.3008f, -1.0882f, 5.6268f);
vec3 colors_LogLuv32ToSRGB(in vec4 vLogLuv) {
	if (all(lessThanEqual(vLogLuv, vec4(0.0f)))) {
		return vec3(0.0f);
	}
	float Le = vLogLuv.z * 255 + vLogLuv.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2((Le - 127) / 2);
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;
	Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;
	vec3 vRGB = _COLORS_LOGLUV32_INVERSE_M * Xp_Y_XYZp;
	return max(vRGB, 0);
}
float colors_karisWeight(vec3 color) {
	float luma = dot(color.rgb, _colors2_colorspaces_mat_ACES_AP1_to_CIE_XYZ[1]);
	return 1.0f / (1.0f + luma);
}
const float _WATER_SCATTERING_MULTIPLIER = exp2(-8.75f);
const float _WATER_ABOSORPTION_MULTIPLIER = exp2(-9.25f);
const vec3 _WATER_SCATTERING_COEFF = vec3(14, 22, 38);
const vec3 _WATER_ABOSORPTION_COEFF = vec3(100, 40, 24);
vec3 WATER_SCATTERING = (_WATER_SCATTERING_COEFF * _WATER_SCATTERING_MULTIPLIER * _colors2_colorspaces_mat_SRGB_to_ACES_AP1);
vec3 WATER_ABOSORPTION = (_WATER_ABOSORPTION_COEFF * _WATER_ABOSORPTION_MULTIPLIER * _colors2_colorspaces_mat_SRGB_to_ACES_AP1);
vec3 WATER_EXTINCTION = WATER_SCATTERING + WATER_ABOSORPTION;
struct ScatteringResult {
	vec3 transmittance;
	vec3 inScattering;
};
ScatteringResult scatteringResult_init() {
	ScatteringResult result;
	result.transmittance = vec3(1.0f);
	result.inScattering = vec3(0.0f);
	return result;
}
vec3 scatteringResult_apply(ScatteringResult result, vec3 color) {
	return result.transmittance * color + result.inScattering;
}
ScatteringResult scatteringResult_blendLayer(ScatteringResult result, ScatteringResult layer, bool aboveLayer) {
	ScatteringResult newResult;
	if (aboveLayer) {
		newResult.inScattering = result.inScattering * layer.transmittance + layer.inScattering;
		newResult.transmittance = result.transmittance * layer.transmittance;
	}
	else {
		newResult.inScattering = layer.inScattering * result.transmittance + result.inScattering;
		newResult.transmittance = layer.transmittance * result.transmittance;
	}
	return newResult;
}
struct AtmosphereParameters {
	float bottom;
	float top;
	float mieHeight;
	vec3 rayleighSctrCoeff;
	vec3 rayleighExtinction;
	vec3 mieSctrCoeff;
	vec3 mieExtinction;
	float miePhaseG;
	float miePhaseE;
	vec3 ozoneExtinction;
};
vec3 atmosphere_mieCoefficientsPreetham(float turbidity) {
	const vec3 a0 = vec3(-0.00767542206226f, -0.00822772032997f, -0.0121707541321f);
	const vec3 a1 = vec3(0.00771550875198f, 0.00827069152678f, 0.0122343187466f);
	return (a0 + a1 * turbidity * _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP1);
}
AtmosphereParameters getAtmosphereParameters() {
	const float ATMOSPHERE_BOTTOM = 6378.137f;
	const float ATMOSPHERE_TOP = ATMOSPHERE_BOTTOM + 100.0f;
	const float MIE_HEIGHT = 1.2f;
	const vec3 RAYLEIGH_SCATTERING_BASE = (vec3(0.0120766817597f, 0.0129498634753f, 0.0275704559807f) * _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP1);
	vec3 RAYLEIGH_SCATTERING = RAYLEIGH_SCATTERING_BASE * 1.0f;
	vec3 MIE_SCATTERING_BASE = atmosphere_mieCoefficientsPreetham(global_turbidity);
	vec3 MIE_SCATTERING = MIE_SCATTERING_BASE * 1.0f;
	vec3 MIE_ABOSORPTION = MIE_SCATTERING_BASE * 0.1f;
	const float MIE_PHASE_G = 0.7034f;
	const float MIE_PHASE_E = 2500.0f;
	const vec3 OZONE_ABOSORPTION_BASE = (vec3(3.2964135827E-10f, 2.9538443418E-10f, 3.7326149468E-11f) * 100000.0f * _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP1);
	const vec3 OZONE_ABOSORPTION = OZONE_ABOSORPTION_BASE * 1.0f;
	AtmosphereParameters atmosphere;
	atmosphere.bottom = ATMOSPHERE_BOTTOM;
	atmosphere.top = ATMOSPHERE_TOP;
	atmosphere.mieHeight = MIE_HEIGHT;
	atmosphere.rayleighSctrCoeff = RAYLEIGH_SCATTERING;
	atmosphere.rayleighExtinction = RAYLEIGH_SCATTERING;
	atmosphere.miePhaseG = MIE_PHASE_G;
	atmosphere.miePhaseE = MIE_PHASE_E;
	atmosphere.mieSctrCoeff = MIE_SCATTERING;
	atmosphere.mieExtinction = MIE_SCATTERING + MIE_ABOSORPTION;
	atmosphere.ozoneExtinction = OZONE_ABOSORPTION;
	return atmosphere;
}
const vec2 TRANSMITTANCE_TEXTURE_SIZE = vec2(256, 64);
const vec2 TRANSMITTANCE_TEXEL_SIZE = 1.0f / TRANSMITTANCE_TEXTURE_SIZE;
float rand_stbnVec1(ivec2 texelPos, uint frame) {
	return texelFetch(usam_stbnVec1, ivec3(texelPos, frame) & ivec3(127, 127, 63), 0).x;
}
vec2 rand_stbnVec2(ivec2 texelPos, uint frame) {
	return texelFetch(usam_stbnVec2, ivec3(texelPos, frame) & ivec3(127, 127, 63), 0).xy;
}
vec2 rand_stbnUnitVec201(ivec2 texelPos, uint frame) {
	return normalize(texelFetch(usam_stbnUnitVec2, ivec3(texelPos, frame) & ivec3(127, 127, 63), 0).xy);
}
vec2 rand_stbnUnitVec211(ivec2 texelPos, uint frame) {
	return normalize(texelFetch(usam_stbnUnitVec2, ivec3(texelPos, frame) & ivec3(127, 127, 63), 0).xy * 2.0f - 1.0f);
}
float rand_IGN(vec2 v) {
	return fract(52.9829189f * fract(0.06711056f * v.x + 0.00583715f * v.y));
}
float rand_IGN(vec2 v, uint frame) {
	frame = frame % 64u;
	v = v + 5.588238f * float(frame);
	return fract(52.9829189f * fract(0.06711056f * v.x + 0.00583715f * v.y));
}
float rand_r2Seq1(uint idx) {
	const float g = 1.618033988749895f;
	const float a = 1.0f - 1.0f / g;
	return 1.0f - fract(a * idx - 0.5f);
}
vec2 rand_r2Seq2(uint idx) {
	const float g = 1.324717957244746f;
	const vec2 a = 1.0f - vec2(1.0f / g, 1.0f / (g * g));
	return 1.0f - fract(a * idx - 0.5f);
}
vec3 rand_r2Seq3(uint idx) {
	const float g = 1.2207440846057596f;
	const vec3 a = 1.0f - vec3(1.0f / g, 1.0f / (g * g), 1.0f / (g * g * g));
	return 1.0f - fract(a * idx - 0.5f);
}
vec3 rand_sampleInCone(vec3 center, float coneHalfAngle, vec2 rand) {
	float phi = (2.0f * 3.141592653589793f) * rand.x;
	float cosTheta = cos(coneHalfAngle);
	float cosAlpha = mix(1.0f, cosTheta, rand.y);
	float sinAlpha = sqrt(1.0f - cosAlpha * cosAlpha);
	vec3 other = abs(center.x) < 0.9f ? vec3(1, 0, 0) : vec3(0, 1, 0);
	vec3 u = normalize(cross(center, other));
	vec3 v = cross(center, u);
	return normalize(cosAlpha * center + sinAlpha * (cos(phi) * u + sin(phi) * v));
}
vec4 dither_u8(vec4 x, float noiseV) {
	vec4 result = x;
	result *= 255.0f;
	result = round(result + (noiseV - 0.5f));
	result /= 255.0f;
	return result;
}
vec3 dither_u8(vec3 x, float noiseV) {
	vec3 result = x;
	result *= 255.0f;
	result = round(result + (noiseV - 0.5f));
	result /= 255.0f;
	return result;
}
vec2 dither_u8(vec2 x, float noiseV) {
	vec2 result = x;
	result *= 255.0f;
	result = round(result + (noiseV - 0.5f));
	result /= 255.0f;
	return result;
}
float dither_u8(float x, float noiseV) {
	float result = x;
	result *= 255.0f;
	result = round(result + (noiseV - 0.5f));
	result /= 255.0f;
	return result;
}
vec4 dither_fp16(vec4 x, float noiseV) {
	return uintBitsToFloat(floatBitsToUint(x) + uint(float(0x7fffu) * (noiseV - 0.5f)));
}
vec3 dither_fp16(vec3 x, float noiseV) {
	return uintBitsToFloat(floatBitsToUint(x) + uint(float(0x7fffu) * (noiseV - 0.5f)));
}
vec2 dither_fp16(vec2 x, float noiseV) {
	return uintBitsToFloat(floatBitsToUint(x) + uint(float(0x7fffu) * (noiseV - 0.5f)));
}
float dither_fp16(float x, float noiseV) {
	return uintBitsToFloat(floatBitsToUint(x) + uint(float(0x7fffu) * (noiseV - 0.5f)));
}
const float UNIFORM_PHASE = 1.0f / (4.0f * 3.141592653589793f);
float phasefunc_Rayleigh(float cosTheta) {
	float k = 3.0f / (16.0f * 3.141592653589793f);
	return k * (1.0f + pow2(cosTheta));
}
float phasefunc_HenyeyGreenstein(float cosTheta, float g) {
	float g2 = pow2(g);
	float numerator = 1.0f - g2;
	float denominator = pow(1.0f + g2 - 2.0f * g * cosTheta, 3.0f / 2.0f);
	float term0 = UNIFORM_PHASE;
	float term1 = numerator / denominator;
	return term0 * term1;
}
vec3 phasefunc_HenyeyGreenstein(float cosTheta, vec3 g) {
	vec3 g2 = pow2(g);
	vec3 numerator = 1.0f - g2;
	vec3 denominator = pow(1.0f + g2 - 2.0f * g * cosTheta, vec3(3.0f / 2.0f));
	float term0 = UNIFORM_PHASE;
	vec3 term1 = numerator / denominator;
	return term0 * term1;
}
float phasefunc_CornetteShanks(float cosTheta, float g) {
	float k = 3.0f / (8.0f * 3.141592653589793f) * (1.0f - g * g) / (2.0f + g * g);
	return k * (1.0f + pow2(cosTheta)) / pow(1.0f + g * g - 2.0f * g * cosTheta, 1.5f);
}
vec3 phasefunc_CornetteShanks(float cosTheta, vec3 g) {
	vec3 k = 3.0f / (8.0f * 3.141592653589793f) * (1.0f - g * g) / (2.0f + g * g);
	return k * (1.0f + pow2(cosTheta)) / pow(1.0f + g * g - 2.0f * g * cosTheta, vec3(1.5f));
}
float phasefunc_Draine(float cosTheta, float g, float alpha) {
	float g2 = pow2(g);
	float numerator1 = 1.0f - g2;
	float denominator1 = pow(1.0f + g2 - 2.0f * g * cosTheta, 3.0f / 2.0f);
	float numerator2 = 1.0f + alpha * pow2(cosTheta);
	float denominator2 = 1.0f + alpha * (1.0f + 2.0f * g2) / 3.0f;
	float term0 = UNIFORM_PHASE;
	float term1 = numerator1 / denominator1;
	float term2 = numerator2 / denominator2;
	return term0 * term1 * term2;
}
float phasefunc_HenyeyGreensteinDraine(float cosTheta, float d) {
	float gHG = exp(-0.0990567f / (d - 1.67154f));
	float gD = exp(-2.20679f / (d + 3.91029f) - 0.428934f);
	float a = exp(3.62489f - 8.29288f / (d + 5.52825f));
	float wD = exp(-0.599085f / (d - 0.641583f) - 0.665888f);
	return mix(phasefunc_HenyeyGreenstein(cosTheta, gHG), phasefunc_Draine(cosTheta, gD, a), wD);
}
float phasefunc_BiLambertianPlate(float cosTheta, float g) {
	float phase = 2.0f * (-3.141592653589793f * g * cosTheta + sqrt(clamp(1.0f - pow2(cosTheta), 0.0f, 1.0f)) + cosTheta * acos(-cosTheta));
	return phase / (3.0f * pow2(3.141592653589793f));
}
float phasefunc_KleinNishinaE(float cosTheta, float e) {
	return e / (2.0f * 3.141592653589793f * (e * (1.0f - cosTheta) + 1.0f) * log(2.0f * e + 1.0f));
}
vec3 phasefunc_KleinNishinaE(float cosTheta, vec3 e) {
	return e / (2.0f * 3.141592653589793f * (e * (1.0f - cosTheta) + 1.0f) * log(2.0f * e + 1.0f));
}
float phasefunc_KleinNishina(float cosTheta, float g) {
	float e = 1.0f;
	for (int i = 0; i < 8; ++i) {
		float gFromE = 1.0f / e - 2.0f / log(2.0f * e + 1.0f) + 1.0f;
		float deriv = 4.0f / ((2.0f * e + 1.0f) * pow2(log(2.0f * e + 1.0f))) - 1.0f / pow2(e);
		e = e - (gFromE - g) / deriv;
	}
	return phasefunc_KleinNishinaE(cosTheta, e);
}
vec3 phasefunc_KleinNishina(float cosTheta, vec3 g) {
	vec3 e = vec3(1.0f);
	for (int i = 0; i < 8; ++i) {
		vec3 gFromE = 1.0f / e - 2.0f / log(2.0f * e + 1.0f) + 1.0f;
		vec3 deriv = 4.0f / ((2.0f * e + 1.0f) * pow2(log(2.0f * e + 1.0f))) - 1.0f / pow2(e);
		e = e - (gFromE - g) / deriv;
	}
	return phasefunc_KleinNishinaE(cosTheta, e);
}
float sampleRayleighDensity(AtmosphereParameters atmosphere, float altitude) {
	const float a0 = 0.00947927584794f;
	const float a1 = -0.138528179963f;
	const float a2 = -0.00235619411773f;
	return exp2(a0 + a1 * altitude + a2 * altitude * altitude);
}
float sampleMieDensity(AtmosphereParameters atmosphere, float altitude) {
	return exp(-altitude / atmosphere.mieHeight);
}
float sampleOzoneDensity(AtmosphereParameters atmosphere, float altitude) {
	float x = max(altitude, 0.0f);
	float x2 = x * x;
	float x3 = x2 * x;
	float x4 = x2 * x2;
	const float d10 = 3.14463183276f;
	const float d11 = 0.0498300739786f;
	const float d12 = -0.13053950591f;
	const float d13 = 0.021937805502f;
	const float d14 = -9.31031499395E-4f;
	float d1 = exp2(d10 + d11 * x + d12 * x2 + d13 * x3 + d14 * x4);
	const float d20 = -15.9975955967f;
	const float d21 = 2.79421136239f;
	const float d22 = -0.128226752502f;
	const float d23 = 0.00249280242662f;
	const float d24 = -1.85558309121E-5f;
	float d2 = exp2(d20 + d21 * x + d22 * x2 + d23 * x3 + d24 * x4);
	return d1 + d2;
}
vec3 sampleParticleDensity(AtmosphereParameters atmosphere, float height) {
	float altitude = height - atmosphere.bottom;
	return vec3(sampleRayleighDensity(atmosphere, altitude), sampleMieDensity(atmosphere, altitude), sampleOzoneDensity(atmosphere, altitude));
}
float atmosphere_height(AtmosphereParameters atmosphere, float worldPosY) {
	float worldHeight = max(worldPosY - 62.0f, float(1000) * 0.001f);
	return worldHeight * (1.0f / float(1000)) + atmosphere.bottom;
}
vec3 atmosphere_viewToAtm(AtmosphereParameters atmosphere, vec3 viewPos) {
	vec3 feetPlayer = (gbufferModelViewInverse * vec4(viewPos, 1.0f)).xyz;
	vec3 world = feetPlayer + cameraPosition;
	float height = atmosphere_height(atmosphere, world.y);
	return vec3(feetPlayer.x, 0.0f, feetPlayer.z) * (1.0f / float(1000)) + vec3(0.0f, height, 0.0f);
}
float atmosphere_heightNoClamping(AtmosphereParameters atmosphere, vec3 worldPos) {
	float worldHeight = worldPos.y - 62.0f;
	return worldHeight * (1.0f / float(1000)) + atmosphere.bottom;
}
vec3 atmosphere_viewToAtmNoClamping(AtmosphereParameters atmosphere, vec3 viewPos) {
	vec3 feetPlayer = (gbufferModelViewInverse * vec4(viewPos, 1.0f)).xyz;
	vec3 world = feetPlayer + cameraPosition;
	float height = atmosphere_heightNoClamping(atmosphere, world);
	return vec3(world.x, 0.0f, world.z) * (1.0f / float(1000)) + vec3(0.0f, height, 0.0f);
}
void unpackEpipolarData(uvec4 epipolarData, out ScatteringResult sctrResult, out float viewZ) {
	vec2 unpacked1 = unpackHalf2x16(epipolarData.x);
	vec2 unpacked2 = unpackHalf2x16(epipolarData.y);
	vec2 unpacked3 = unpackHalf2x16(epipolarData.z);
	sctrResult.inScattering = vec3(unpacked1.xy, unpacked2.x);
	sctrResult.transmittance = vec3(unpacked2.y, unpacked3.xy);
	viewZ = uintBitsToFloat(epipolarData.w);
}
void packEpipolarData(out uvec4 epipolarData, ScatteringResult sctrResult, ivec2 texelPos) {
	epipolarData.x = packHalf2x16(sctrResult.inScattering.xy);
	epipolarData.y = packHalf2x16(vec2(sctrResult.inScattering.z, sctrResult.transmittance.x));
	epipolarData.z = packHalf2x16(sctrResult.transmittance.yz);
	epipolarData.w = bitfieldInsert(texelPos.x, texelPos.y, 16, 16);
}
bool isValidScreenLocation(vec2 f2XY) {
	const float SAFETY_EPSILON = 0.2f;
	return all(lessThanEqual(abs(f2XY), 1.0f - (1.0f - SAFETY_EPSILON) / vec2(uval_mainImageSizeI)));
}
vec4 getOutermostScreenPixelCoords() {
	return vec4(-1.0f, -1.0f, 1.0f, 1.0f) + vec4(1.0f, 1.0f, -1.0f, -1.0f) / uval_mainImageSizeI.xyxy;
}
vec4 temporalUpdate(vec4 prevData, vec3 currData, float maxFrames, ivec2 texelPos) {
	vec4 newResult = vec4(0.0f);
	newResult.a = min(prevData.a + 1.0f, maxFrames);
	newResult.rgb = mix(prevData.rgb, currData, 1.0f / newResult.a);
	newResult.rgb = dither_fp16(newResult.rgb, rand_stbnVec1(texelPos, frameCounter));
	return newResult;
}
mat3 mat3_rotateX(float angle) {
	float c = cos(angle);
	float s = sin(angle);
	return mat3(1.0f, 0.0f, 0.0f, 0.0f, c, -s, 0.0f, s, c);
}
mat3 mat3_rotateY(float angle) {
	float c = cos(angle);
	float s = sin(angle);
	return mat3(c, 0.0f, s, 0.0f, 1.0f, 0.0f, -s, 0.0f, c);
}
mat3 mat3_rotateZ(float angle) {
	float c = cos(angle);
	float s = sin(angle);
	return mat3(c, -s, 0.0f, s, c, 0.0f, 0.0f, 0.0f, 1.0f);
}
float coords_linearizeDepth(float depth, float near, float far) {
	return (near * far) / (depth * (near - far) + far);
}
float coords_viewZToReversedZ(float viewZ, float near) {
	return near / -viewZ;
}
float coords_reversedZToViewZ(float revZ, float near) {
	return near / -revZ;
}
vec3 coords_toViewCoord(vec2 texCoord, float viewZ, mat4 projInv) {
	vec2 ndcXY = texCoord * 2.0f - 1.0f;
	vec2 clipXY = ndcXY * -viewZ;
	vec2 viewXY = clipXY * vec2(projInv[0][0], projInv[1][1]);
	return vec3(viewXY, viewZ);
}
vec2 OctWrap(vec2 v) {
	return (1.0f - abs(v.yx)) * mix(vec2(-1.0f), vec2(1.0f), greaterThanEqual(v.xy, vec2(0.0f)));
}
vec3 coords_octDecode11(vec2 f) {
	vec3 n = vec3(f.x, f.y, 1.0f - abs(f.x) - abs(f.y));
	float t = clamp(-n.z, 0.0f, 1.0f);
	n.xy += mix(vec2(t), vec2(-t), greaterThanEqual(n.xy, vec2(0.0f)));
	return normalize(n);
}
vec2 coords_octEncode11(vec3 n) {
	n /= (abs(n.x) + abs(n.y) + abs(n.z));
	n.xy = n.z >= 0.0f ? n.xy : OctWrap(n.xy);
	return n.xy;
}
vec4 coords_projDiv(mat4 m, vec4 c) {
	vec4 r = m * c;
	return r / r.w;
}
vec4 coord_sceneCurrToPrev(vec4 sceneCurr, bool isHand) {
	vec3 cameraDelta = isHand ? vec3(0.0f) : uval_cameraDelta;
	vec4 scenePrev = sceneCurr;
	scenePrev.xyz += cameraDelta;
	return scenePrev;
}
vec4 coord_sceneCurrToPrev(vec4 sceneCurr) {
	vec3 cameraDelta = uval_cameraDelta;
	vec4 scenePrev = sceneCurr;
	scenePrev.xyz += cameraDelta;
	return scenePrev;
}
vec4 coord_scenePrevToCurr(vec4 scenePrev) {
	vec3 cameraDelta = uval_cameraDelta;
	vec4 sceneCurr = scenePrev;
	sceneCurr.xyz -= cameraDelta;
	return sceneCurr;
}
vec4 coord_viewCurrToPrev(vec4 currViewPos, bool isHand) {
	vec4 currScenePos = gbufferModelViewInverse * currViewPos;
	vec4 prevViewCoord;
	if (isHand) {
		currScenePos.xyz = currScenePos.xyz + gbufferModelViewInverse[3].xyz;
		vec4 prevScenePos = currScenePos;
		prevScenePos.xyz = prevScenePos.xyz - gbufferPrevModelViewInverse[3].xyz;
		prevViewCoord = gbufferModelView * prevScenePos;
	}
	else {
		vec4 prevScenePos = coord_sceneCurrToPrev(currScenePos);
		prevViewCoord = gbufferPrevModelView * prevScenePos;
	}
	return prevViewCoord;
}
vec3 coords_octDecode01(vec2 f) {
	return coords_octDecode11(f * 2.0f - 1.0f);
}
vec2 coords_octEncode01(vec3 n) {
	return coords_octEncode11(n) * 0.5f + 0.5f;
}
vec2 coords_equirectanglarForward(vec3 direction) {
	float phi = atan(direction.z, direction.x);
	float theta = asin(direction.y);
	vec2 uv = vec2((phi + 3.141592653589793f) / (2.0f * 3.141592653589793f), (theta + 3.141592653589793f / 2.0f) / 3.141592653589793f);
	return uv;
}
vec3 coords_equirectanglarBackward(vec2 uv) {
	float phi = uv.x * 2.0f * 3.141592653589793f - 3.141592653589793f;
	float theta = uv.y * 3.141592653589793f - 3.141592653589793f / 2.0f;
	vec3 direction = vec3(cos(theta) * cos(phi), sin(theta), cos(theta) * sin(phi));
	return normalize(direction);
}
vec2 coords_equirectanglarForwardHorizonBoost(vec3 direction) {
	float phi = atan(direction.z, direction.x);
	float theta = asin(direction.y);
	vec2 uv = vec2((phi + 3.141592653589793f) / (2.0f * 3.141592653589793f), 0.5f + 0.5f * sign(theta) * sqrt(abs(theta) * (1.0f / (0.5f * 3.141592653589793f))));
	return uv;
}
vec3 coords_equirectanglarBackwardHorizonBoost(vec2 uv) {
	float phi = uv.x * 2.0f * 3.141592653589793f - 3.141592653589793f;
	float theta = uv.y * 2.0f - 1.0f;
	theta = sign(theta) * pow2(theta);
	theta *= (0.5f * 3.141592653589793f);
	vec3 direction = vec3(cos(theta) * cos(phi), sin(theta), cos(theta) * sin(phi));
	return normalize(direction);
}
vec2 coords_mercatorForward(vec3 direction) {
	float lon = atan(direction.z, direction.x);
	float lat = asin(direction.y);
	vec2 uv = vec2((lon + 3.141592653589793f) / (2.0f * 3.141592653589793f), 0.5f + log(tan(3.141592653589793f / 4.0f + lat / 2.0f)) / (2.0f * 3.141592653589793f));
	return uv;
}
vec3 coords_mercatorBackward(vec2 uv) {
	float lon = uv.x * 2.0f * 3.141592653589793f - 3.141592653589793f;
	float lat = 2.0f * atan(exp((uv.y - 0.5f) * 2.0f * 3.141592653589793f)) - 3.141592653589793f / 2.0f;
	vec3 direction = vec3(cos(lat) * cos(lon), sin(lat), cos(lat) * sin(lon));
	return normalize(direction);
}
void coords_cubeMapForward(vec3 direction, out vec2 sliceUV, out vec2 sliceID) {
	vec4 axisDataX = vec4(direction.yz, direction.x, 0.0f);
	vec4 axisDataY = vec4(direction.xz, direction.y, 1.0f);
	vec4 axisDataZ = vec4(direction.xy, direction.z, 2.0f);
	vec4 maxAxisData = axisDataX;
	maxAxisData = abs(direction.y) > abs(maxAxisData.z) ? axisDataY : maxAxisData;
	maxAxisData = abs(direction.z) > abs(maxAxisData.z) ? axisDataZ : maxAxisData;
	sliceUV = (maxAxisData.xy / abs(maxAxisData.z)) * 0.5f + 0.5f;
	sliceID = vec2(float(maxAxisData.z > 0.0f), float(maxAxisData.w));
}
void coords_cubeMapBackward(out vec3 direction, vec2 sliceUV, vec2 sliceID) {
	vec3 directionTemp = vec3(sliceID.x, sliceUV) * 2.0f - 1.0f;
	directionTemp = sliceID.y == 1.0f ? directionTemp.yxz : directionTemp;
	directionTemp = sliceID.y == 2.0f ? directionTemp.yzx : directionTemp;
	direction = normalize(directionTemp);
}
vec2 coords_texelToUV(ivec2 texelPos, vec2 rcpTextureSize) {
	return clamp((vec2(texelPos) + 0.5f) * rcpTextureSize, 0.0f, 1.0f);
}
ivec2 coords_clampTexelPos(ivec2 texelPos, ivec2 imageSizeV) {
	return clamp(texelPos, ivec2(0), imageSizeV);
}
const mat3 _COORDS_EQUATORIAL_TO_GALACTIC = mat3(-0.0548755604f, 0.4941094279f, -0.867666149f, -0.8734370902f, -0.44482963f, -0.1980763734f, -0.4838350155f, 0.7469822445f, 0.4559837762f);
vec3 coords_equatorialToGalactic(vec3 equatorial) {
	return _COORDS_EQUATORIAL_TO_GALACTIC * equatorial;
}
const mat3 _COORDS_WORLD_TO_EQUATORIAL = mat3(0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f);
vec3 coords_worldToEquatorial(vec3 world) {
	return _COORDS_WORLD_TO_EQUATORIAL * world;
}
vec3 coords_equatorial_observerRotation(vec3 equatorial, float solarLon, float hourAngle, float observerLat) {
	mat3 latRotation = mat3_rotateY(observerLat);
	mat3 solarRotation = mat3_rotateZ(3.141592653589793f - solarLon - hourAngle);
	return solarRotation * latRotation * equatorial;
}
vec2 coords_equatorial_rectangularToSpherical(vec3 equatorial) {
	float dec = asin(equatorial.z);
	float ra = atan(equatorial.y, equatorial.x);
	return vec2(ra, dec);
}
vec3 coords_dir_viewToWorld(vec3 dirView) {
	return normalize((mat3(gbufferModelViewInverse) * dirView));
}
vec3 coords_dir_worldToView(vec3 dirWorld) {
	return normalize((mat3(gbufferModelView) * dirWorld));
}
vec3 coords_viewToScreen(vec3 viewPos, mat4 proj) {
	vec4 clipPos = proj * vec4(viewPos, 1.0f);
	vec3 ndcPos = clipPos.xyz / clipPos.w;
	return ndcPos * 0.5f + 0.5f;
}
float _celestial_circle(vec3 rayDir, vec3 objDir, float objAngularRadius) {
	float objCosTheta = cos(objAngularRadius);
	float cosTheta = clamp(dot(rayDir, objDir), 0.0f, 1.0f);
	return float(cosTheta >= objCosTheta);
}
const float _CELESTIAL_STARMAP_MILKYWAY_LUMINANCE = 0.1927554f;
const float _CELESTIAL_REAL_MILKYWAY_LUMINANCE_MCD = 1.5f;
const float _CELESTIAL_REAL_MILKYWAY_LUMINANCE_KCD = _CELESTIAL_REAL_MILKYWAY_LUMINANCE_MCD / 1000000.0f;
const float _CELESTIAL_STARMAP_EXP = _CELESTIAL_REAL_MILKYWAY_LUMINANCE_KCD / _CELESTIAL_STARMAP_MILKYWAY_LUMINANCE;
const vec2 _CELESTIAL_STARMAP_SIZE = vec2(8192.0f, 4096.0f);
vec4 BicubicSampling5(sampler2D samplerV, vec2 inHistoryUV, vec2 resolution) {
	vec2 inHistoryST = inHistoryUV * resolution;
	const vec2 rcpResolution = (1.0f / (resolution));
	const vec2 fractional = fract(inHistoryST - 0.5f);
	const vec2 uv = (floor(inHistoryST - 0.5f) + vec2(0.5f, 0.5f)) * rcpResolution;
	const vec2 t = vec2(fractional);
	const vec2 t2 = vec2(fractional * fractional);
	const vec2 t3 = vec2(fractional * fractional * fractional);
	const float s = float(0.5f);
	const vec2 w0 = -s * t3 + float(2.0f) * s * t2 - s * t;
	const vec2 w1 = (float(2.0f) - s) * t3 + (s - float(3.0f)) * t2 + float(1.0f);
	const vec2 w2 = (s - float(2.0f)) * t3 + (3 - float(2.0f) * s) * t2 + s * t;
	const vec2 w3 = s * t3 - s * t2;
	const vec2 s0 = w1 + w2;
	const vec2 f0 = w2 / (w1 + w2);
	const vec2 m0 = uv + f0 * rcpResolution;
	const vec2 tc0 = uv - 1.0f * rcpResolution;
	const vec2 tc3 = uv + 2.0f * rcpResolution;
	const vec4 A = vec4(texture(samplerV, vec2(m0.x, tc0.y)));
	const vec4 B = vec4(texture(samplerV, vec2(tc0.x, m0.y)));
	const vec4 C = vec4(texture(samplerV, vec2(m0.x, m0.y)));
	const vec4 D = vec4(texture(samplerV, vec2(tc3.x, m0.y)));
	const vec4 E = vec4(texture(samplerV, vec2(m0.x, tc3.y)));
	const vec4 color = (float(0.5f) * (A + B) * w0.x + A * s0.x + float(0.5f) * (A + B) * w3.x) * w0.y + (B * w0.x + C * s0.x + D * w3.x) * s0.y + (float(0.5f) * (B + E) * w0.x + E * s0.x + float(0.5f) * (D + E) * w3.x) * w3.y;
	return color;
}
vec4 celestial_render(ivec2 texelPos, inout vec4 temp6Out) {
	vec2 screenPos = (vec2(texelPos) + 0.5f - global_taaJitter) * uval_mainImageSizeRcp;
	vec3 viewCoord = coords_toViewCoord(screenPos, -far, global_camProjInverse);
	vec3 viewDir = normalize(viewCoord);
	vec3 viewDirWorld = mat3(gbufferModelViewInverse) * viewDir;
	AtmosphereParameters atmosphere = getAtmosphereParameters();
	vec3 origin = atmosphere_viewToAtm(atmosphere, vec3(0.0f));
	origin.y = max(origin.y, atmosphere.bottom + 0.5f);
	const vec3 earthCenter = vec3(0.0f);
	float earthIntersect = raySphereIntersectNearest(origin, viewDirWorld, earthCenter, atmosphere.bottom);
	float earthOcclusionV = step(earthIntersect, 0.0f);
	float sunV = earthOcclusionV * _celestial_circle(viewDir, uval_sunDirView, atan((695700.0f * 1.0f) / (1.495978707E8f * 1.0f)) * 2.0f);
	float moonV = earthOcclusionV * _celestial_circle(viewDir, uval_moonDirView, atan((1737.4f * 1.0f) / (384399 * 1.0f)) * 2.0f);
	float moonDarkV = earthOcclusionV * _celestial_circle(viewDir, uval_moonDirView, atan((1737.4f * 1.0f) / (384399 * 1.0f)) * 4.0f);
	vec4 result = vec4(0.0f, 0.0f, 0.0f, 1.0f);
	result += sunV * vec4(((683.002f * mix(exp2(vec3(-3.72901753986E7f, -4.08109129676E7f, -4.7350510215E7f) * (1.0f / (pow2(5772.0f))) + vec3(7055.3581938f, 6758.95549072f, 4118.25228444f) * (1.0f / (5772.0f)) + vec3(0.00484537801959f, 0.00491276883428f, 0.00506185958018f) * 5772.0f + vec3(-6.810769857E-7f, -6.950213321E-7f, -6.9539565265E-7f) * pow2(5772.0f) + vec3(5.6731538598E-11f, 5.8002399769E-11f, 5.6337103621E-11f) * pow3(5772.0f) + vec3(-2.5703246799E-15f, -2.6264426188E-15f, -2.4816463488E-15f) * pow4(5772.0f) + vec3(4.8909354617E-20f, 4.9886030965E-20f, 4.5966064285E-20f) * pow5(5772.0f)), vec3(-8005.4231085f, -12668.5089522f, 90350.9871613f) + vec3(-13.8986440037f, -13.5414550402f, -53.296767586f) * 5772.0f + vec3(0.00322233921192f, 0.00326336194057f, 0.00762350264707f) * pow2(5772.0f) + vec3(-8.7157145477E-8f, -8.8899800557E-8f, -2.0127905863E-7f) * pow3(5772.0f) + vec3(1.2119660239E-12f, 1.242334591E-12f, 2.7501969304E-12f) * pow4(5772.0f) + vec3(-6.7641067868E-18f, -6.9583618131E-18f, -1.5149377815E-17f) * pow5(5772.0f), smoothstep(9000.0f, 10000.0f, float(5772.0f)))) * _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP1), 1.0f);
	result += moonV * vec4(((((683.002f * mix(exp2(vec3(-3.72901753986E7f, -4.08109129676E7f, -4.7350510215E7f) * (1.0f / (pow2(5772.0f))) + vec3(7055.3581938f, 6758.95549072f, 4118.25228444f) * (1.0f / (5772.0f)) + vec3(0.00484537801959f, 0.00491276883428f, 0.00506185958018f) * 5772.0f + vec3(-6.810769857E-7f, -6.950213321E-7f, -6.9539565265E-7f) * pow2(5772.0f) + vec3(5.6731538598E-11f, 5.8002399769E-11f, 5.6337103621E-11f) * pow3(5772.0f) + vec3(-2.5703246799E-15f, -2.6264426188E-15f, -2.4816463488E-15f) * pow4(5772.0f) + vec3(4.8909354617E-20f, 4.9886030965E-20f, 4.5966064285E-20f) * pow5(5772.0f)), vec3(-8005.4231085f, -12668.5089522f, 90350.9871613f) + vec3(-13.8986440037f, -13.5414550402f, -53.296767586f) * 5772.0f + vec3(0.00322233921192f, 0.00326336194057f, 0.00762350264707f) * pow2(5772.0f) + vec3(-8.7157145477E-8f, -8.8899800557E-8f, -2.0127905863E-7f) * pow3(5772.0f) + vec3(1.2119660239E-12f, 1.242334591E-12f, 2.7501969304E-12f) * pow4(5772.0f) + vec3(-6.7641067868E-18f, -6.9583618131E-18f, -1.5149377815E-17f) * pow5(5772.0f), smoothstep(9000.0f, 10000.0f, float(5772.0f)))) * _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP1) * (2.0f * 3.141592653589793f * (1.0f - sqrt(pow2((1.495978707E8f * 1.0f)) - pow2((695700.0f * 1.0f))) / (1.495978707E8f * 1.0f)))) * (0.12f * vec3(0.8f, 0.9f, 1.0f)) * (1.0f / 3.141592653589793f)), 0.0f);
	result += moonDarkV * vec4(0.0f, 0.0f, 0.0f, -0.95f);
	float solarPos = 0.25f;
	float hourAngle = float(worldTime - 18000) / 24000.0f * (2.0f * 3.141592653589793f);
	vec3 starmapDir = viewDirWorld;
	starmapDir = coords_worldToEquatorial(starmapDir);
	starmapDir = coords_equatorial_observerRotation(starmapDir, solarPos * (2.0f * 3.141592653589793f), hourAngle, radians(43.0f));
	vec2 starmapSpherical = coords_equatorial_rectangularToSpherical(normalize(starmapDir));
	vec2 starmapUV = vec2(starmapSpherical.x * (1.0f / 3.141592653589793f) * -0.5f + 0.5f, starmapSpherical.y * (1.0f / 3.141592653589793f) + 0.5f);
	vec3 starmap = (colors_LogLuv32ToSRGB(BicubicSampling5(usam_starmap, starmapUV, _CELESTIAL_STARMAP_SIZE)) * _colors2_colorspaces_mat_SRGB_to_ACES_AP1);
	starmap = pow(starmap, vec3(0.8f));
	starmap *= exp2(dot(starmap, _colors2_colorspaces_mat_ACES_AP1_to_CIE_XYZ[1]) * 4);
	result.rgb += earthOcclusionV * starmap * _CELESTIAL_STARMAP_EXP * 6 * 4.0f;
	result.a = max(result.a, 0.0f);
	return result;
}
uint packU10(float v) {
	return uint(clamp(v, 0.0f, 1.0f) * 1023.0f);
}
float unpackU10(uint v) {
	return clamp(float(v) / 1023.0f, 0.0f, 1.0f);
}
uint packS10(float v) {
	return packU10(v * 0.5f + 0.5f);
}
float unpackS10(uint v) {
	return unpackU10(v) * 2.0f - 1.0f;
}
uint packU11(float v) {
	return uint(clamp(v, 0.0f, 1.0f) * 2047.0f);
}
float unpackU11(uint v) {
	return clamp(float(v) / 2047.0f, 0.0f, 1.0f);
}
uint packS11(float v) {
	return packU11(v * 0.5f + 0.5f);
}
float unpackS11(uint v) {
	return unpackU11(v) * 2.0f - 1.0f;
}
uint packU15(float v) {
	return uint(clamp(v, 0.0f, 1.0f) * 32767.0f);
}
float unpackU15(uint v) {
	return clamp(float(v) / 32767.0f, 0.0f, 1.0f);
}
uint packS15(float v) {
	return packU15(v * 0.5f + 0.5f);
}
float unpackS15(uint v) {
	return unpackU15(v) * 2.0f - 1.0f;
}
uint packU16(float v) {
	return uint(clamp(v, 0.0f, 1.0f) * 65535.0f);
}
float unpackU16(uint v) {
	return clamp(float(v) / 65535.0f, 0.0f, 1.0f);
}
uint packS16(float v) {
	return packU16(v * 0.5f + 0.5f);
}
float unpackS16(uint v) {
	return unpackU16(v) * 2.0f - 1.0f;
}
uint packUInt2x16(uvec2 v) {
	uint result = bitfieldInsert(0u, v.x, 0, 16);
	result = bitfieldInsert(result, v.y, 16, 16);
	return result;
}
uvec2 unpackUInt2x16(uint v) {
	uvec2 result = uvec2(bitfieldExtract(v, 0, 16), bitfieldExtract(v, 16, 16));
	return result;
}
uint packSnorm3x10(vec3 v) {
	uint result = packS10(v.x);
	result = bitfieldInsert(result, packS10(v.y), 10, 10);
	result = bitfieldInsert(result, packS10(v.z), 20, 10);
	return result;
}
vec3 unpackSnorm3x10(uint v) {
	vec3 result;
	result.x = unpackS10(bitfieldExtract(v, 0, 10));
	result.y = unpackS10(bitfieldExtract(v, 10, 10));
	result.z = unpackS10(bitfieldExtract(v, 20, 10));
	return result;
}
uvec2 packHalf4x16(vec4 v) {
	return uvec2(packHalf2x16(v.xy), packHalf2x16(v.zw));
}
vec4 unpackHalf4x16(uvec2 v) {
	return vec4(unpackHalf2x16(v.x), unpackHalf2x16(v.y));
}
vec2 nzpacking_fullResGatherUV(vec2 gatherTexelPos) {
	vec2 clampedGatherTexelPos = clamp(gatherTexelPos, vec2(1.0f), uval_mainImageSize - 1);
	clampedGatherTexelPos.y += uval_mainImageSize.y;
	vec2 sizeRcp = uval_mainImageSizeRcp;
	sizeRcp.y *= 0.5f;
	return clampedGatherTexelPos * sizeRcp;
}
uint nzpacking_packNormalOct32(vec3 normal) {
	return packSnorm2x16(coords_octEncode11(normal));
}
vec3 nzpacking_unpackNormalOct32(uint packedNormal) {
	return coords_octDecode11(unpackSnorm2x16(packedNormal));
}
void nzpacking_packNormalOct16(out uint packedNormal, vec3 normal1, vec3 normal2) {
	vec4 xyzw = vec4(coords_octEncode11(normal1), coords_octEncode11(normal2));
	packedNormal = packSnorm4x8(xyzw);
}
void nzpacking_unpackNormalOct16(uint packedNormal, out vec3 normal1, out vec3 normal2) {
	vec4 xyzw = unpackSnorm4x8(packedNormal);
	normal1 = coords_octDecode11(xyzw.xy);
	normal2 = coords_octDecode11(xyzw.zw);
}
void nzpacking_pack(out uvec2 packedData, vec3 normal, float depth) {
	packedData.x = nzpacking_packNormalOct32(normal);
	packedData.y = floatBitsToUint(depth);
}
void nzpacking_unpack(uvec2 packedData, out vec3 normal, out float depth) {
	normal = nzpacking_unpackNormalOct32(packedData.x);
	depth = uintBitsToFloat(packedData.y);
}
const uint MATERIAL_ID_UNDEFINED = 65535u;
struct GBufferData {
	vec3 geomNormal;
	vec3 geomTangent;
	vec4 pbrSpecular;
	vec3 normal;
	vec2 lmCoord;
	uint materialID;
	vec3 albedo;
	bool isHand;
	int bitangentSign;
};
GBufferData gbufferData_init() {
	GBufferData gData;
	gData.geomNormal = vec3(0.0f);
	gData.geomTangent = vec3(0.0f);
	gData.pbrSpecular = vec4(0.0f);
	gData.normal = vec3(0.0f);
	gData.lmCoord = vec2(0.0f);
	gData.materialID = MATERIAL_ID_UNDEFINED;
	gData.albedo = vec3(0.0f);
	gData.isHand = false;
	return gData;
}
void gbufferData1_pack(out uvec4 packedData, GBufferData gData) {
	nzpacking_packNormalOct16(packedData.r, coords_dir_viewToWorld(gData.geomNormal), coords_dir_viewToWorld(gData.geomTangent));
	packedData.g = packUnorm4x8(vec4(gData.pbrSpecular));
	packedData.b = nzpacking_packNormalOct32(coords_dir_viewToWorld(gData.normal));
	packedData.a = packUnorm4x8(vec4(gData.lmCoord, 0.0f, 0.0f)) & 0xffffu;
	packedData.a |= (gData.materialID & 0xffffu) << 16;
}
void gbufferData1_unpack(uvec4 packedData, inout GBufferData gData) {
	nzpacking_unpackNormalOct16(packedData.r, gData.geomNormal, gData.geomTangent);
	gData.geomNormal = coords_dir_worldToView(gData.geomNormal);
	gData.geomTangent = coords_dir_worldToView(gData.geomTangent);
	gData.pbrSpecular = unpackUnorm4x8(packedData.g);
	gData.normal = coords_dir_worldToView(nzpacking_unpackNormalOct32(packedData.b));
	gData.lmCoord = unpackUnorm4x8(packedData.a).xy;
	gData.materialID = (packedData.a >> 16) & 0xffffu;
}
void gbufferData2_pack(out uvec4 packedData, GBufferData gData) {
	packedData.r = packUnorm4x8(vec4(gData.albedo, 0.0f)) & 0xffffffu;
	packedData.r = bitfieldInsert(packedData.r, uint(gData.isHand), 24, 1);
	packedData.r = bitfieldInsert(packedData.r, uint(clamp(gData.bitangentSign, 0, 1)), 25, 1);
}
void gbufferData2_unpack(uvec4 packedData, inout GBufferData gData) {
	gData.albedo = unpackUnorm4x8(packedData.r).rgb;
	gData.isHand = bool(bitfieldExtract(packedData.r, 24, 1));
	gData.bitangentSign = int(bitfieldExtract(packedData.r, 25, 1)) * 2 - 1;
}
struct Material {
	vec3 albedo;
	float roughness;
	float f0;
	float metallic;
	vec3 emissive;
	float porosity;
	float sss;
	float hardCodedIOR;
	mat3 tbn;
	mat3 tbnInv;
};
const float _MATERIAL_F0_EPSILON = exp2(-12);
const float _MATERIAL_ROUGHNESS_MULTIPLIER = 1.0f;
const float _MATERIAL_MINIMUM_ROUGHNESS = exp2(-6);
const float _MATERIAL_MAXIMUM_ROUGHNESS = 1.0f - exp2(-5);
Material material_decode(GBufferData gData) {
	Material material;
	material.albedo = (colors2_eotf_3(gData.albedo) * _colors2_colorspaces_mat_SRGB_to_ACES_AP1);
	material.roughness = 1.0f - gData.pbrSpecular.r;
	material.roughness *= material.roughness;
	material.roughness *= _MATERIAL_ROUGHNESS_MULTIPLIER;
	material.roughness = mix(_MATERIAL_MINIMUM_ROUGHNESS, _MATERIAL_MAXIMUM_ROUGHNESS, smoothstep(_MATERIAL_MINIMUM_ROUGHNESS, _MATERIAL_MAXIMUM_ROUGHNESS, material.roughness));
	material.f0 = gData.pbrSpecular.g;
	material.metallic = float(material.f0 >= (229.5f / 255.0f));
	float emissivePBR = pow(gData.pbrSpecular.a, 0.9f);
	vec4 emissiveAlbedoCurve = vec4(vec3(2.0f), 0.5f);
	float albedoLuminanceAlternative = dot(material.albedo, _colors2_colorspaces_mat_ACES_AP1_to_CIE_XYZ[1]);
	vec4 emissiveAlbedo = pow(vec4(material.albedo, albedoLuminanceAlternative), emissiveAlbedoCurve);
	float MATERIAL_LAVA_LUMINANCE = dot(((683.002f * mix(exp2(vec3(-3.72901753986E7f, -4.08109129676E7f, -4.7350510215E7f) * (1.0f / (pow2(1300))) + vec3(7055.3581938f, 6758.95549072f, 4118.25228444f) * (1.0f / (1300)) + vec3(0.00484537801959f, 0.00491276883428f, 0.00506185958018f) * 1300 + vec3(-6.810769857E-7f, -6.950213321E-7f, -6.9539565265E-7f) * pow2(1300) + vec3(5.6731538598E-11f, 5.8002399769E-11f, 5.6337103621E-11f) * pow3(1300) + vec3(-2.5703246799E-15f, -2.6264426188E-15f, -2.4816463488E-15f) * pow4(1300) + vec3(4.8909354617E-20f, 4.9886030965E-20f, 4.5966064285E-20f) * pow5(1300)), vec3(-8005.4231085f, -12668.5089522f, 90350.9871613f) + vec3(-13.8986440037f, -13.5414550402f, -53.296767586f) * 1300 + vec3(0.00322233921192f, 0.00326336194057f, 0.00762350264707f) * pow2(1300) + vec3(-8.7157145477E-8f, -8.8899800557E-8f, -2.0127905863E-7f) * pow3(1300) + vec3(1.2119660239E-12f, 1.242334591E-12f, 2.7501969304E-12f) * pow4(1300) + vec3(-6.7641067868E-18f, -6.9583618131E-18f, -1.5149377815E-17f) * pow5(1300), smoothstep(9000.0f, 10000.0f, float(1300)))) * _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP1), _colors2_colorspaces_mat_ACES_AP1_to_CIE_XYZ[1]);
	float MATERIAL_FIRE_LUMINANCE = dot(((683.002f * mix(exp2(vec3(-3.72901753986E7f, -4.08109129676E7f, -4.7350510215E7f) * (1.0f / (pow2(1400))) + vec3(7055.3581938f, 6758.95549072f, 4118.25228444f) * (1.0f / (1400)) + vec3(0.00484537801959f, 0.00491276883428f, 0.00506185958018f) * 1400 + vec3(-6.810769857E-7f, -6.950213321E-7f, -6.9539565265E-7f) * pow2(1400) + vec3(5.6731538598E-11f, 5.8002399769E-11f, 5.6337103621E-11f) * pow3(1400) + vec3(-2.5703246799E-15f, -2.6264426188E-15f, -2.4816463488E-15f) * pow4(1400) + vec3(4.8909354617E-20f, 4.9886030965E-20f, 4.5966064285E-20f) * pow5(1400)), vec3(-8005.4231085f, -12668.5089522f, 90350.9871613f) + vec3(-13.8986440037f, -13.5414550402f, -53.296767586f) * 1400 + vec3(0.00322233921192f, 0.00326336194057f, 0.00762350264707f) * pow2(1400) + vec3(-8.7157145477E-8f, -8.8899800557E-8f, -2.0127905863E-7f) * pow3(1400) + vec3(1.2119660239E-12f, 1.242334591E-12f, 2.7501969304E-12f) * pow4(1400) + vec3(-6.7641067868E-18f, -6.9583618131E-18f, -1.5149377815E-17f) * pow5(1400), smoothstep(9000.0f, 10000.0f, float(1400)))) * _colors2_colorspaces_mat_ACES_AP0_to_ACES_AP1), _colors2_colorspaces_mat_ACES_AP1_to_CIE_XYZ[1]);
	float emissiveValue = emissivePBR * 0.5f;
	emissiveValue = gData.materialID == 1u ? MATERIAL_LAVA_LUMINANCE : emissiveValue;
	emissiveValue = gData.materialID == 2u ? MATERIAL_FIRE_LUMINANCE : emissiveValue;
	emissiveValue *= exp2(4.0f);
	material.emissive = emissiveValue * emissiveAlbedo.a * emissiveAlbedo.rgb;
	const float _64o255 = 64.0f / 255.0f;
	const float _65o255 = 65.0f / 255.0f;
	float step64 = step(_65o255, gData.pbrSpecular.b);
	material.porosity = linearStep(0.0f, _64o255, gData.pbrSpecular.b);
	material.porosity *= 1.0f - step64;
	material.sss = linearStep(_65o255, 1.0f, gData.pbrSpecular.b);
	material.sss *= step64;
	material.sss = sqrt(material.sss);
	material.hardCodedIOR = 1.0f;
	vec3 bitangent = cross(gData.normal, gData.geomTangent) * float(gData.bitangentSign);
	material.tbn = mat3(gData.geomTangent, bitangent, gData.normal);
	material.tbnInv = inverse(material.tbn);
	return material;
}
uvec2 morton_8bDecode(uint code) {
	uvec2 result = uvec2(code, code >> 1) & 0x55u;
	result = (result | (result >> 1)) & 0x33u;
	result = (result | (result >> 2)) & 0xfu;
	return result;
}
uvec2 morton_16bDecode(uint code) {
	uvec2 result = uvec2(code, code >> 1) & 0x5555u;
	result = (result | (result >> 1)) & 0x3333u;
	result = (result | (result >> 2)) & 0xf0fu;
	result = (result | (result >> 4)) & 0xffu;
	return result;
}
uvec2 morton_32bDecode(uint code) {
	uvec2 result = uvec2(code, code >> 1) & 0x55555555u;
	result = (result | (result >> 1)) & 0x33333333u;
	result = (result | (result >> 2)) & 0xf0f0f0fu;
	result = (result | (result >> 4)) & 0xff00ffu;
	result = (result | (result >> 8)) & 0xffffu;
	return result;
}
uint _hash_sum(uvec2 v) {
	return v.x + v.y;
}
uint _hash_sum(uvec3 v) {
	return v.x + v.y + v.z;
}
uint _hash_sum(uvec4 v) {
	return v.x + v.y + v.z + v.w;
}
const uvec4 _HASH_LINEAR_COMB_MAGIC_MUL = uvec4(19u, 47u, 101u, 131u);
const uint _HASH_LINEAR_COMB_MAGIC_ADD = 173u;
uint _hash_linear_comb(uvec2 v) {
	return _hash_sum(_HASH_LINEAR_COMB_MAGIC_MUL.xy * v) + _HASH_LINEAR_COMB_MAGIC_ADD;
}
uint _hash_linear_comb(uvec3 v) {
	return _hash_sum(_HASH_LINEAR_COMB_MAGIC_MUL.xyz * v) + _HASH_LINEAR_COMB_MAGIC_ADD;
}
uint _hash_linear_comb(uvec4 v) {
	return _hash_sum(_HASH_LINEAR_COMB_MAGIC_MUL * v) + _HASH_LINEAR_COMB_MAGIC_ADD;
}
uint hash_lcg_11(uint p) {
	return p * 1664525u + 1013904223u;
}
uint hash_lcg_21_linear(uvec2 p) {
	return hash_lcg_11(_hash_linear_comb(p));
}
uint hash_lcg_31_linear(uvec3 p) {
	return hash_lcg_11(_hash_linear_comb(p));
}
uint hash_lcg_41_linear(uvec4 p) {
	return hash_lcg_11(_hash_linear_comb(p));
}
uint hash_pcg_11(uint v) {
	uint state = v * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	return (word >> 22u) ^ word;
}
uvec2 hash_pcg2d_22(uvec2 v) {
	v = v * 1664525u + 1013904223u;
	v.x += v.y * 1664525u;
	v.y += v.x * 1664525u;
	v = v ^ (v >> 16u);
	v.x += v.y * 1664525u;
	v.y += v.x * 1664525u;
	v = v ^ (v >> 16u);
	return v;
}
uvec3 hash_pcg3d16_33(uvec3 v) {
	v = v * 12829u + 47989u;
	v.x += v.y * v.z;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	v.x += v.y * v.z;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	v >>= 16u;
	return v;
}
uvec3 hash_pcg3d_33(uvec3 v) {
	v = v * 1664525u + 1013904223u;
	v.x += v.y * v.z;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	v = v ^ (v >> 16u);
	v.x += v.y * v.z;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	return v;
}
uvec4 hash_pcg4d_44(uvec4 v) {
	v = v * 1664525u + 1013904223u;
	v.x += v.y * v.w;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	v.w += v.y * v.z;
	v = v ^ (v >> 16u);
	v.x += v.y * v.w;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	v.w += v.y * v.z;
	return v;
}
const uint _HASH_XXHASH32_PRIME32_2 = 2246822519u;
const uint _HASH_XXHASH32_PRIME32_3 = 3266489917u;
const uint _HASH_XXHASH32_PRIME32_4 = 668265263u;
const uint _HASH_XXHASH32_PRIME32_5 = 374761393u;
uint hash_xxhash32_11(uint p) {
	uint h32 = p + _HASH_XXHASH32_PRIME32_5;
	h32 = _HASH_XXHASH32_PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17)));
	h32 = _HASH_XXHASH32_PRIME32_2 * (h32 ^ (h32 >> 15));
	h32 = _HASH_XXHASH32_PRIME32_3 * (h32 ^ (h32 >> 13));
	return h32 ^ (h32 >> 16);
}
uint hash_xxhash32_21_multibyte(uvec2 p) {
	uint h32 = p.y + _HASH_XXHASH32_PRIME32_5 + p.x * _HASH_XXHASH32_PRIME32_3;
	h32 = _HASH_XXHASH32_PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17)));
	h32 = _HASH_XXHASH32_PRIME32_2 * (h32 ^ (h32 >> 15));
	h32 = _HASH_XXHASH32_PRIME32_3 * (h32 ^ (h32 >> 13));
	return h32 ^ (h32 >> 16);
}
uint hash_xxhash32_31_multibyte(uvec3 p) {
	uint h32 = p.z + _HASH_XXHASH32_PRIME32_5 + p.x * _HASH_XXHASH32_PRIME32_3;
	h32 = _HASH_XXHASH32_PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17)));
	h32 += p.y * _HASH_XXHASH32_PRIME32_3;
	h32 = _HASH_XXHASH32_PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17)));
	h32 = _HASH_XXHASH32_PRIME32_2 * (h32 ^ (h32 >> 15));
	h32 = _HASH_XXHASH32_PRIME32_3 * (h32 ^ (h32 >> 13));
	return h32 ^ (h32 >> 16);
}
uint hash_xxhash32_41_multibyte(uvec4 p) {
	uint h32 = p.w + _HASH_XXHASH32_PRIME32_5 + p.x * _HASH_XXHASH32_PRIME32_3;
	h32 = _HASH_XXHASH32_PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17)));
	h32 += p.y * _HASH_XXHASH32_PRIME32_3;
	h32 = _HASH_XXHASH32_PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17)));
	h32 += p.z * _HASH_XXHASH32_PRIME32_3;
	h32 = _HASH_XXHASH32_PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17)));
	h32 = _HASH_XXHASH32_PRIME32_2 * (h32 ^ (h32 >> 15));
	h32 = _HASH_XXHASH32_PRIME32_3 * (h32 ^ (h32 >> 13));
	return h32 ^ (h32 >> 16);
}
uint hash_iqint3_21(uvec2 v) {
	uvec2 q = 1103515245u * ((v >> 1u) ^ (v.yx));
	uint n = 1103515245u * ((q.x) ^ (q.y >> 3u));
	return n;
}
uint hash_11_q1(uint v) {
	return hash_lcg_11(v);
}
uint hash_11_q2(uint v) {
	return hash_pcg_11(v);
}
uint hash_11_q3(uint v) {
	return hash_xxhash32_11(v);
}
uint hash_11_q4(uint v) {
	return hash_pcg3d_33(uvec3(v, _HASH_XXHASH32_PRIME32_2, _HASH_XXHASH32_PRIME32_3)).x;
}
uint hash_11_q5(uint v) {
	return hash_pcg4d_44(uvec4(v, _HASH_XXHASH32_PRIME32_2, _HASH_XXHASH32_PRIME32_3, _HASH_XXHASH32_PRIME32_4)).x;
}
uint hash_21_q1(uvec2 v) {
	return hash_lcg_21_linear(v);
}
uint hash_21_q2(uvec2 v) {
	return hash_iqint3_21(v);
}
uint hash_21_q3(uvec2 v) {
	return hash_xxhash32_21_multibyte(v);
}
uint hash_21_q4(uvec2 v) {
	return hash_pcg3d_33(uvec3(v, _HASH_XXHASH32_PRIME32_2)).x;
}
uint hash_21_q5(uvec2 v) {
	return hash_pcg4d_44(uvec4(v, _HASH_XXHASH32_PRIME32_2, _HASH_XXHASH32_PRIME32_3)).x;
}
uint hash_31_q1(uvec3 v) {
	return hash_lcg_31_linear(v);
}
uint hash_31_q2(uvec3 v) {
	return hash_pcg3d16_33(v).x;
}
uint hash_31_q3(uvec3 v) {
	return hash_xxhash32_31_multibyte(v);
}
uint hash_31_q4(uvec3 v) {
	return hash_pcg3d_33(v).x;
}
uint hash_31_q5(uvec3 v) {
	return hash_pcg4d_44(uvec4(v, _HASH_XXHASH32_PRIME32_2)).x;
}
uint hash_41_q1(uvec4 v) {
	return hash_lcg_41_linear(v);
}
uint hash_41_q2(uvec4 v) {
	return hash_xxhash32_41_multibyte(v);
}
uint hash_41_q3(uvec4 v) {
	return hash_xxhash32_41_multibyte(v);
}
uint hash_41_q4(uvec4 v) {
	return hash_pcg4d_44(v).x;
}
uint hash_41_q5(uvec4 v) {
	return hash_pcg4d_44(v).x;
}
uvec2 hash_22_q1(uvec2 v) {
	return hash_pcg2d_22(v);
}
uvec2 hash_22_q2(uvec2 v) {
	return hash_pcg3d_33(uvec3(v, _HASH_XXHASH32_PRIME32_2)).xy;
}
uvec2 hash_22_q3(uvec2 v) {
	return hash_pcg4d_44(uvec4(v, _HASH_XXHASH32_PRIME32_2, _HASH_XXHASH32_PRIME32_3)).xy;
}
uvec3 hash_33_q1(uvec3 v) {
	return hash_pcg3d16_33(v);
}
uvec3 hash_33_q2(uvec3 v) {
	return hash_pcg3d_33(v);
}
uvec3 hash_33_q3(uvec3 v) {
	return hash_pcg4d_44(uvec4(v, _HASH_XXHASH32_PRIME32_2)).xyz;
}
uvec4 hash_44_q1(uvec4 v) {
	return hash_pcg4d_44(v);
}
uvec4 hash_44_q2(uvec4 v) {
	return hash_pcg4d_44(v);
}
uvec4 hash_44_q3(uvec4 v) {
	return hash_pcg4d_44(v);
}
float hash_uintToFloat(uint v) {
	return float(v) * (1.0f / float(0xffffffffu));
}
vec2 hash_uintToFloat(uvec2 v) {
	return vec2(v) * (1.0f / float(0xffffffffu));
}
vec3 hash_uintToFloat(uvec3 v) {
	return vec3(v) * (1.0f / float(0xffffffffu));
}
vec4 hash_uintToFloat(uvec4 v) {
	return vec4(v) * (1.0f / float(0xffffffffu));
}
uint hash_floatToUint(float v) {
	return uint(v * float(0xffffffffu));
}
uvec2 hash_floatToUint(vec2 v) {
	return uvec2(v * float(0xffffffffu));
}
uvec3 hash_floatToUint(vec3 v) {
	return uvec3(v * float(0xffffffffu));
}
uvec4 hash_floatToUint(vec4 v) {
	return uvec4(v * float(0xffffffffu));
}
float hiz_closest_load(ivec2 texelPos, int level) {
	ivec4 mipTile = global_mipmapTiles[0][level];
	ivec2 readPos = mipTile.xy + clamp(texelPos, ivec2(0), mipTile.zw - 1);
	return texelFetch(usam_hiz, readPos, 0).r;
}
float hiz_closest_sample(vec2 texelPos, int level) {
	vec4 mipTile = vec4(global_mipmapTiles[0][level]);
	vec2 readPos = mipTile.xy + clamp(texelPos, vec2(0.5f), mipTile.zw - 0.5f);
	return texture(usam_hiz, readPos / vec2(textureSize(usam_hiz, 0))).r;
}
vec4 hiz_closest_gather(vec2 texelPos, int level) {
	vec4 mipTile = vec4(global_mipmapTiles[0][level]);
	vec2 readPos = mipTile.xy + clamp(texelPos, vec2(1.0f), mipTile.zw - 1.0f);
	return textureGather(usam_hiz, readPos / vec2(textureSize(usam_hiz, 0)), 0);
}
bool hiz_groupGroundCheck(uvec2 groupOrigin, int level) {
	return hiz_closest_load(ivec2(groupOrigin), level) > coords_viewZToReversedZ(-65536.0f, near);
}
bool hiz_groupGroundCheckSubgroup(uvec2 groupOrigin, int level) {
	bool subgroupCheck = false;
	if (subgroupElect()) {
		subgroupCheck = hiz_closest_load(ivec2(groupOrigin), level) > coords_viewZToReversedZ(-65536.0f, near);
	}
	return subgroupBroadcastFirst(subgroupCheck);
}
bool hiz_groupGroundCheck4x4(vec2 groupOrigin, int level) {
	vec4 hizValues = hiz_closest_gather(groupOrigin + vec2(-1.0f, -1.0f), level);
	hizValues = max(hizValues, hiz_closest_gather(groupOrigin + vec2(1.0f, -1.0f), level));
	hizValues = max(hizValues, hiz_closest_gather(groupOrigin + vec2(-1.0f, 1.0f), level));
	hizValues = max(hizValues, hiz_closest_gather(groupOrigin + vec2(1.0f, 1.0f), level));
	return max4(hizValues) > coords_viewZToReversedZ(-65536.0f, near);
}
float hiz_furthest_load(ivec2 texelPos, int level) {
	ivec4 mipTile = global_mipmapTiles[1][level];
	ivec2 readPos = mipTile.xy + clamp(texelPos, ivec2(0), mipTile.zw - 1);
	return texelFetch(usam_hiz, readPos, 0).r;
}
float hiz_furthest_sample(vec2 texelPos, int level) {
	vec4 mipTile = vec4(global_mipmapTiles[1][level]);
	vec2 readPos = mipTile.xy + clamp(texelPos, vec2(0.5f), mipTile.zw - 0.5f);
	return texture(usam_hiz, readPos / vec2(textureSize(usam_hiz, 0))).g;
}
vec4 hiz_furthest_gather(vec2 texelPos, int level) {
	vec4 mipTile = vec4(global_mipmapTiles[1][level]);
	vec2 readPos = mipTile.xy + clamp(texelPos, vec2(1.0f), mipTile.zw - 1.0f);
	return textureGather(usam_hiz, readPos / vec2(textureSize(usam_hiz, 0)), 0);
}
bool hiz_groupSkyCheck(uvec2 groupOrigin, int level) {
	return hiz_furthest_load(ivec2(groupOrigin), level) <= coords_viewZToReversedZ(-65536.0f, near);
}
bool hiz_groupSkyCheckSubgroup(uvec2 groupOrigin, int level) {
	bool subgroupCheck = false;
	if (subgroupElect()) {
		subgroupCheck = hiz_furthest_load(ivec2(groupOrigin), level) <= coords_viewZToReversedZ(-65536.0f, near);
	}
	return subgroupBroadcastFirst(subgroupCheck);
}
bool hiz_groupSkyCheck4x4(vec2 groupOrigin, int level) {
	vec4 hizValues = hiz_furthest_gather(groupOrigin + vec2(-1.0f, -1.0f), level);
	hizValues = min(hizValues, hiz_furthest_gather(groupOrigin + vec2(1.0f, -1.0f), level));
	hizValues = min(hizValues, hiz_furthest_gather(groupOrigin + vec2(-1.0f, 1.0f), level));
	hizValues = min(hizValues, hiz_furthest_gather(groupOrigin + vec2(1.0f, 1.0f), level));
	return min4(hizValues) <= coords_viewZToReversedZ(-65536.0f, near);
}
layout(local_size_x = 16, local_size_y = 16) in;
const vec2 workGroupsRender = vec2(1.0f, 1.0f);
layout(rgba16f) uniform restrict image2D colorimg3;
layout(r32i) uniform iimage2D uimg_rtwsm_imap;
layout(rgba16f) uniform restrict image2D colorimg11;
vec2 rtwsm_warpTexCoord(sampler2D warpingMap, vec2 uv) {
	vec2 result = uv;
	result.x += texture(warpingMap, vec2(uv.x, (258.5f / 262.0f))).r;
	result.y += texture(warpingMap, vec2(uv.y, (259.5f / 262.0f))).r;
	return result;
}
vec2 rtwsm_warpTexCoordTexelSize(sampler2D warpingMap, vec2 uv, out vec2 texelSize) {
	vec2 result = uv;
	result.x += texture(warpingMap, vec2(uv.x, (258.5f / 262.0f))).r;
	result.y += texture(warpingMap, vec2(uv.y, (259.5f / 262.0f))).r;
	texelSize.x = texture(warpingMap, vec2(uv.x, (260.5f / 262.0f))).r;
	texelSize.y = texture(warpingMap, vec2(uv.y, (261.5f / 262.0f))).r;
	return result;
}
float rtwsm_sampleShadowDepth(sampler2DShadow shadowMap, vec3 coord, float lod) {
	vec2 ndcCoord = coord.xy * 2.0f - 1.0f;
	float edgeCoord = max(abs(ndcCoord.x), abs(ndcCoord.y));
	return mix(textureLod(shadowMap, coord, lod), 1.0f, linearStep(1.0f - SHADOW_MAP_SIZE.y * 16, 1.0f, edgeCoord));
}
vec4 rtwsm_sampleShadowColor(sampler2D shadowColor, vec2 coord, float lod) {
	return textureLod(shadowColor, coord, lod);
}
float rtwsm_sampleShadowDepth(sampler2D shadowMap, vec3 coord, float lod) {
	uint flag = uint(any(lessThan(coord.xy, vec2(0.0f))));
	flag |= uint(any(greaterThan(coord.xy, vec2(1.0f))));
	return mix(textureLod(shadowMap, coord.xy, lod).r, coord.z, float(flag));
}
float rtwsm_linearDepth(float d) {
	return mix(-global_shadowAABBMaxPrev.z - 512.0f, -global_shadowAABBMinPrev.z + 16.0f, d);
}
float rtwsm_linearDepthInverse(float depth) {
	return linearStep(-global_shadowAABBMaxPrev.z - 512.0f, -global_shadowAABBMinPrev.z + 16.0f, depth);
}
shared vec3 shared_shadowAABBMin[16];
shared vec3 shared_shadowAABBMax[16];
void shadowAABB1(vec3 shadowViewPos) {
	vec3 min1 = subgroupMin(shadowViewPos);
	vec3 max1 = subgroupMax(shadowViewPos);
	if (subgroupElect()) {
		shared_shadowAABBMin[gl_SubgroupID] = min1;
		shared_shadowAABBMax[gl_SubgroupID] = max1;
	}
}
void shadowAABB2() {
	if (gl_SubgroupID == 0 && gl_SubgroupInvocationID < gl_NumSubgroups) {
		vec3 min2 = shared_shadowAABBMin[gl_SubgroupInvocationID];
		vec3 max2 = shared_shadowAABBMax[gl_SubgroupInvocationID];
		vec3 min3 = subgroupMin(min2);
		vec3 max3 = subgroupMax(max2);
		if (subgroupElect()) {
			ivec3 min4 = ivec3(floor(min3 / 16.0f)) * 16;
			ivec3 max4 = ivec3(ceil(max3 / 16.0f)) * 16;
			atomicMin(global_shadowAABBMinNew.x, min4.x);
			atomicMin(global_shadowAABBMinNew.y, min4.y);
			atomicMin(global_shadowAABBMinNew.z, min4.z);
			atomicMax(global_shadowAABBMaxNew.x, max4.x);
			atomicMax(global_shadowAABBMaxNew.y, max4.y);
			atomicMax(global_shadowAABBMaxNew.z, max4.z);
		}
	}
}
void importance(ivec2 texelPos, float viewZ, GBufferData gData, out uint p, out float v) {
	vec2 screenPos = (vec2(texelPos) + 0.5f - global_taaJitter) * uval_mainImageSizeRcp;
	vec3 viewPos = coords_toViewCoord(screenPos, viewZ, global_camProjInverse);
	float importance = 5.0f;
	if (dot(viewPos, viewPos) > shadowDistance * shadowDistance) {
		viewPos = vec3(0.0f);
		importance = 0.0f;
	}
	vec4 scenePos = gbufferModelViewInverse * vec4(viewPos, 1.0f);
	vec4 shadowViewPos = global_shadowRotationMatrix * shadowModelView * scenePos;
	shadowAABB1(shadowViewPos.xyz);
	vec4 shadowClipPos = global_shadowProj * shadowViewPos;
	vec3 shadowNDCPos = shadowClipPos.xyz / shadowClipPos.w;
	vec2 shadowScreenPos = shadowNDCPos.xy * 0.5f + 0.5f;
	importance *= 1.0f / (1.0f + pow(dot(viewPos, viewPos), 0.6f));
	vec3 viewDir = normalize(-viewPos);
	importance *= 1.0f + 2.0f * clamp(dot(gData.geomNormal, viewDir), 0.0f, 1.0f);
	float lightDir = dot(gData.geomNormal, uval_shadowLightDirView);
	importance *= 1.0f + 4.0f * pow(1.0f - lightDir * lightDir, float(16));
	if (any(greaterThanEqual(abs(shadowClipPos.xy), vec2(1.0f)))) {
		p = 0xffffffffu;
		v = 0u;
		return;
	}
	uvec2 shadowPos = uvec2(shadowScreenPos.xy * 256);
	importance = max(importance, uval_rtwsmMin.y);
	p = shadowPos.y << 16 | shadowPos.x;
	v = importance;
	return;
}
void writeOutput(uint p, float v) {
	if (p == 0xffffffffu) return;
	imageAtomicMax(uimg_rtwsm_imap, ivec2(p & 0xffffu, p >> 16), floatBitsToInt(v));
}
void backwardOutput(uint p, float v) {
	uvec4 pballot = subgroupPartitionNV(p);
	float maxV = subgroupPartitionedMaxNV(v, pballot);
	if (subgroupBallotFindLSB(pballot) == gl_SubgroupInvocationID) {
		writeOutput(p, maxV);
	}
}
void rtwsm_backward(ivec2 texelPos, float viewZ, GBufferData gData) {
	if (gl_LocalInvocationIndex < 16) {
		shared_shadowAABBMax[gl_LocalInvocationIndex] = vec3(0.0f);
		shared_shadowAABBMin[gl_LocalInvocationIndex] = vec3(0.0f);
	}
	barrier();
	if (!gData.isHand) {
		uint p;
		float v;
		importance(texelPos, viewZ, gData, p, v);
		backwardOutput(p, v);
	}
	barrier();
	shadowAABB2();
}
ivec2 texelPos = ivec2(0);
GBufferData gData = gbufferData_init();
vec3 viewPos = vec3(0.0f);
vec3 viewDir = vec3(0.0f);
vec2 texel2Screen(ivec2 texelPos) {
	return (vec2(texelPos) + 0.5f) * uval_mainImageSizeRcp;
}
float searchBlocker(vec3 shadowTexCoord) {
	float blockerSearchRange = 0.1f;
	uint idxB = frameCounter * 2 + (hash_31_q3(floatBitsToUint(viewPos.xyz)) & 1023u);
	float blockerDepth = 0.0f;
	int n = 0;
	for (int i = 0; i < 2; i++) {
		vec2 randomOffset = (rand_r2Seq2(idxB) * 2.0f - 1.0f);
		vec3 sampleTexCoord = shadowTexCoord;
		sampleTexCoord.xy += randomOffset * blockerSearchRange * vec2(global_shadowProjPrev[0][0], global_shadowProjPrev[1][1]);
		sampleTexCoord.xy = rtwsm_warpTexCoord(usam_rtwsm_imap, sampleTexCoord.xy);
		float depth = rtwsm_sampleShadowDepth(shadowtex1, sampleTexCoord, 4).r;
		bool isBlocker = sampleTexCoord.z > depth;
		blockerDepth += float(isBlocker) * depth;
		n += int(isBlocker);
		idxB++;
	}
	blockerDepth /= float(max(n, 1));
	blockerDepth = mix(shadowTexCoord.z, blockerDepth, float(n != 0));
	return abs(rtwsm_linearDepth(blockerDepth) - rtwsm_linearDepth(shadowTexCoord.z));
}
float waterSurfaceDistance(vec3 shadowUVPos) {
	shadowUVPos.xy = rtwsm_warpTexCoord(usam_rtwsm_imap, shadowUVPos.xy);
	vec2 ndcCoord = shadowUVPos.xy * 2.0f - 1.0f;
	float edgeCoord = max(abs(ndcCoord.x), abs(ndcCoord.y));
	if (edgeCoord > 1.0f - SHADOW_MAP_SIZE.y * 16) {
		return -1.0f;
	}
	if (texture(shadowcolor5, shadowUVPos.xy).r < 0.9f) {
		return -1.0f;
	}
	float sampleDepth = texture(shadowtex0, shadowUVPos.xy).r;
	if (texture(shadowtex1, shadowUVPos.xy).r <= sampleDepth) {
		return -1.0f;
	}
	return abs(rtwsm_linearDepth(shadowUVPos.z) - rtwsm_linearDepth(sampleDepth));
}
vec3 calcShadow(Material material) {
	float sssFactor = material.sss;
	uint skipFlag = uint(dot(gData.normal, uval_upDirView) < -0.99f);
	skipFlag &= uint(sssFactor < 0.001f);
	if (bool(skipFlag)) {
		return vec3(0.0f);
	}
	float cosLightTheta = dot(uval_shadowLightDirView, gData.geomNormal);
	float sideFacingFactor = 1.0f - abs(cosLightTheta);
	vec3 offsetViewPos = viewPos;
	offsetViewPos += gData.geomNormal * mix(0.01f, 0.03f, sideFacingFactor);
	vec4 scenePos = gbufferModelViewInverse * vec4(offsetViewPos, 1.0f);
	vec4 shadowViewPos = global_shadowRotationMatrix * global_shadowView * scenePos;
	vec4 shadowClipPos = global_shadowProjPrev * shadowViewPos;
	vec3 shadowNDCPos = shadowClipPos.xyz / shadowClipPos.w;
	vec3 shadowScreenPos = shadowNDCPos * 0.5f + 0.5f;
	float blockerDistance = searchBlocker(shadowScreenPos);
	float ssRange = 0.0f;
	ssRange += atan((695700.0f * 1.0f) / (1.495978707E8f * 1.0f)) * 2.0f * 1.0f * blockerDistance;
	ssRange = clamp(ssRange, 0.0f, 1.0f);
	ssRange += sssFactor * 0.3f;
	const float ssRangeMul = 0.5f;
	ssRange *= ssRangeMul;
	float jitterR = rand_stbnVec1(texelPos, frameCounter);
	vec2 dir = rand_stbnUnitVec211(texelPos, frameCounter);
	float sqrtJitterR = sqrt(jitterR);
	float r = sqrtJitterR * ssRange;
	vec3 sampleTexCoord = shadowScreenPos;
	sampleTexCoord.xy += r * dir * vec2(global_shadowProjPrev[0][0], global_shadowProjPrev[1][1]);
	vec2 texelSize;
	sampleTexCoord.xy = rtwsm_warpTexCoordTexelSize(usam_rtwsm_imap, sampleTexCoord.xy, texelSize);
	float sampleShadowDepthOffset = rtwsm_sampleShadowColor(shadowcolor0, sampleTexCoord.xy, 0.0f).x;
	sampleTexCoord.z -= max(sampleShadowDepthOffset, 0.0f);
	vec3 worldGeometryNormal = mat3(gbufferModelViewInverse) * gData.geomNormal;
	vec3 sampleNormal = rtwsm_sampleShadowColor(shadowcolor1, sampleTexCoord.xy, 0.0f).xyz;
	float shadowNormalCos = dot(worldGeometryNormal, sampleNormal);
	float confidance = pow2(shadowNormalCos * 0.5f + 0.5f);
	confidance = subgroupClusteredMax(confidance, 16);
	float depthBiasFactor = 2.0f;
	depthBiasFactor += (1.0f - pow2(1.0f - sideFacingFactor)) * 8.0f;
	depthBiasFactor *= confidance;
	float depthBiasConstant = 0.02f;
	depthBiasConstant += sideFacingFactor * 0.03f;
	depthBiasConstant *= pow2(confidance);
	float depthBias = SHADOW_MAP_SIZE.y * depthBiasFactor / min(texelSize.x, texelSize.y);
	sampleTexCoord.z = rtwsm_linearDepth(sampleTexCoord.z);
	sampleTexCoord.z -= jitterR * min(sssFactor * 0.6f, 0.9f);
	sampleTexCoord.z -= depthBias;
	sampleTexCoord.z -= depthBiasConstant;
	sampleTexCoord.z = rtwsm_linearDepthInverse(sampleTexCoord.z);
	float sampleShadow0 = rtwsm_sampleShadowDepth(shadowtex0HW, sampleTexCoord, 0.0f);
	float sampleShadow1 = rtwsm_sampleShadowDepth(shadowtex1HW, sampleTexCoord, 0.0f);
	vec4 sampleColor = rtwsm_sampleShadowColor(shadowcolor2, sampleTexCoord.xy, 0.0f);
	sampleColor.rgb = (colors2_eotf_3(sampleColor.rgb) * _colors2_colorspaces_mat_SRGB_to_ACES_AP1);
	sampleColor.rgb = mix(vec3(1.0f), sampleColor.rgb, float(sampleShadow0 < 1.0f));
	vec3 shadow = min(sampleColor.rgb, sampleShadow1.rrr);
	if (texture(shadowcolor5, sampleTexCoord.xy).r > 0.9f) {
		float rcpShadowY = (1.0f / (uval_shadowLightDirWorld.y));
		vec4 scenePos = gbufferModelViewInverse * vec4(viewPos, 1.0f);
		float worldHeight = scenePos.y + cameraPosition.y;
		float waterDepth = waterSurfaceDistance(shadowScreenPos);
		if (waterDepth == -1.0f) {
			max(63.0f - worldHeight, 0.0f) * rcpShadowY;
		}
		shadow *= exp(-waterDepth * WATER_EXTINCTION);
	}
	float shadowRangeBlend = linearStep(shadowDistance - 8.0f, shadowDistance, length(scenePos.xz));
	return mix(vec3(shadow), vec3(1.0f), shadowRangeBlend);
}
vec4 compShadow(ivec2 texelPos, float viewZ) {
	vec2 screenPos = texel2Screen(texelPos);
	Material material = material_decode(gData);
	viewPos = coords_toViewCoord(screenPos, viewZ, global_camProjInverse);
	viewDir = normalize(-viewPos);
	return vec4(calcShadow(material), 1.0f);
}
void main() {
	uvec2 workGroupOrigin = gl_WorkGroupID.xy << 4;
	uint threadIdx = gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID;
	uvec2 mortonPos = morton_8bDecode(threadIdx);
	uvec2 mortonGlobalPosU = workGroupOrigin + mortonPos;
	texelPos = ivec2(mortonGlobalPosU);
	if (all(lessThan(texelPos, uval_mainImageSizeI))) {
		float viewZ = -65536.0f;
		if (hiz_groupGroundCheckSubgroup(gl_WorkGroupID.xy, 4)) {
			viewZ = texelFetch(colortex10, texelPos, 0).r;
		}
		if (viewZ != -65536.0f) {
			gbufferData1_unpack(texelFetch(colortex8, texelPos, 0), gData);
			gbufferData2_unpack(texelFetch(colortex9, texelPos, 0), gData);
			vec4 outputColor = compShadow(texelPos, viewZ);
			outputColor = clamp(outputColor, 0.0f, 65504.0f);
			imageStore(colorimg3, texelPos, outputColor);
			rtwsm_backward(texelPos, viewZ, gData);
		}
	}
}
